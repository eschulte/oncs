# -*- mode:org -*-
#+Options: ^:nil

* replace =num_lambda_messages_for= with something faster (state?)
Any solution will require that the result for a particular ONC will
require interrogation of the value for all sub-oncs in the entire
structure.  If this will be maintained rather than calculated on the
fly (which is slow), then we'll need a way for ONCs to link /back/ up
to their parents...  This would be a fairly major change.

Track this in bits of state
- lambda-msg counter could count the number of lambda messages
  directed towards an ONC.  This could easily be maintained per ONC as
  messages are enqueued and dequeued.
- value-p bit could track if an ONC is value and update itself in
  response to lambda messages

Called from:
| func                    | for                                   |
|-------------------------+---------------------------------------|
| num_lambda_messages_for | recursion                             |
| app_abs                 | for the bodies of lambda applications |
| run                     | elimination of duplicate nesting      |

** DONE keep a counter of incoming lambda messages for each onc
After this change the time for running file:test/fact-o-2.c goes from
48 seconds to 5 seconds.

** assuming we add a backwards link
Tracking value-p of each ONC becomes the ∧ of the value-p of its car
and cdr, which are either immediately calculated by their type, or if
LOCAL are the result of the pointed-to ONC.  With backwards-facing
links then changes in value-p can be propagated back up the chain.

* why so slow
: $ time ./test/y-comb-2.test
: ./test/y-comb-2.test  51.51s user 0.00s system 99% cpu 51.583 total

** the culprit is obvious
gprof output for test/fact-o-2.test
: Each sample counts as 0.01 seconds.
:   %   cumulative   self              self     total           
:  time   seconds   seconds    calls   s/call   s/call  name    
:  90.55     44.75    44.75   640473     0.00     0.00  num_lambda_messages_for
:   4.96     47.20     2.45 34767872     0.00     0.00  coord_hash
:   2.53     48.45     1.25    33951     0.00     0.00  enqueue
:   0.51     48.70     0.25    33953     0.00     0.00  queue_hash
:   0.50     48.94     0.25    33953     0.00     0.00  run_all
:   0.45     49.16     0.22  5718842     0.00     0.00  run
:   0.18     49.25     0.09  5684891     0.00     0.00  run_at
:   0.16     49.33     0.08    67908     0.00     0.00  ptr_to_string
:   0.08     49.37     0.04   680828     0.00     0.00  value_p
:   0.06     49.40     0.03    33953     0.00     0.00  world_hash
:   0.02     49.41     0.01  5752890     0.00     0.00  debug
:   0.02     49.42     0.01   262687     0.00     0.00  app_abs
:   0.01     49.43     0.01        1     0.01    49.43  fix

** fact 2
: $ time test/fact-o-1.test
: test/fact-o-1.test  48.52s user 0.00s system 99% cpu 48.591 total

** fact 3
: 19:36 bagel:oncs time ./test/fact.test -v|tail -40
: Q[0]
: :
: expr(16,16):(*3 (*2))
: hash:12d68470
: 
:      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
:  0                  i9^                     L2^             i1^         i1_
:  1                                      ^1_
:  2                                              ^1_ i9_ @1^
:  3                          i1^     L1^                     @10^                 ^1_
:  4                              i2^         @1^ @1^         @1^                 i1^
:  5
:  6                                      i1^ ^1_                 ^1_
:  7                                                          L1^     ^1^
:  8                                      ^1_                 ^1^ ^10^ ^1_
:  9                                                              L1^ L1^
: 10                                                                  ^1_
: 11
: 12
: 13
: 14
: 15                  ^10_
: 16              ^10_ ^10_         L1^ ^2_                             ^1_
: 17              ^1_
: 18                              L1^
: 19                              ^1_
: 20                                                  ^1_
: 21                                                  ^10_
: 22              i10_             ^10_                 ^1_
: 23                                      ^2_
: 24                                              s1_
: 25      s10_                         i1_ i1_     i2_     i1_
: 26              i10_
: 27      L10^     i1_                     ^1_ @1^
: 28      s1_ s10_         s2_                 s1_                                     s1_
: 29                      ^10_             @1^                 s1^                 ^1_ s10_
: 30                                          @1^ ^1_ i1_         s10^ ^1_     i2^     s1_
: 31                                          ^1_                 s1^                 i9^
: Q[0]
: :
: expr(16,16):(*3 (*2))
: hash:12d68470
: ./test/fact.test -v  53.27s user 1.31s system 99% cpu 54.681 total
: tail -40  2.04s user 1.00s system 5% cpu 54.681 total

* probably prim-opts need similar pre-exec checks to lambdas
Distill into a =safe_arg= or =safe_to_apply= function.

Maybe this is needed for EXTEND as well?

It looks like curried operations applied to =LOCAL='s pointing to
=LAMBDA='s end up erasing the =LAMBDA='s.

This could be a symptom
: ((*2 ((#L0 (= #S0 0 1 (* #S0 (-1 #S0)))) 1)))
: ((*2 )))

To see this up close run gdb overtop of primopt with
: break app_abs if place.x == 8 && place.y == 7

* DONE might consider de-nesting
So that =((1))= -> =1=.

This reduces the number of expressions, but may make writing and
evaluating expressions easier.

If this isn't done during evaluation then it should maybe be done
during translation of written expressions into ONC expressions.

* fact-0 bug
gdb
: break app_abs if (place.x == 8 && place.y == 4)
: break run     if (place.x == 8 && place.y == 4 && world[8][2].car.hdr == 2)

Somehow when =(-0 1)= is replace with =TRUE=, it's =cdr= is lost.

As if the boolean is =UNPACK='ed out from under the reference, which
then pushes the reference back to point part way into the =BOOLEAN=.

: =0 1 1 2
: TRUE 1 2

: +1 1 3 4
: 2 3 4

* consider inbound messages for ONCS which are moved in app_abs
=app_abs= will now /move/ linked ONCS into the place of a lambda
abstraction when it is applied.  This causes problems when those ONC
structures have inbound message.

** Ideas -- may need to revisit this on different architectures
*** DONE delay λ-application or app_abs when argument has λ-messages
The only time this happens over a distance is λ-application, so maybe
we can just deal with this at =lambda_app= and =app_abs=.

- Skip over =lambda_app= and =app_abs= when the argument has
  outstanding λ-messages.  Actually, if we just do this for =app_abs=
  then such arguments won't be enqueued and we don't need to worry
  about those on the queue.

*** apply message *before* the move
Actually, it would be better to /apply/ all message to the ONC before
it is duplicated away.  This avoids the two problems of;
- messages restarting propagation from the new location of the copied
  ONC could escape through to places it was never meant to visit
- large message duplication

Just this of this as pulling the ONC through it's message queue on its
way out of the square.  The problem then becomes, how to stall the
execution of the copying action while all of these other actions
complete.  It seems that any deviation from purely local interactions
(e.g., copying instantly and remotely in this case) tends to cause
problems down the line... Perhaps it is time to re-implement *all*
copy and movement through local messages.

*** copy messages
somehow copy (or duplicate) all messages in the queue to the new
location, like send a message down the queue which enqueues all
non-reference messages directed at the copied ONC to the target ONC.
This would work well with the future distributed queue, but could
likely greatly increase the total number of message applications, but
that doesn't really matter as they'll all take place in parallel.

*** stop moving any ONCS with references
Stop moving any ONCS with positive reference counts, and rather just
link to them, maybe with an UNPACK action.

** Possible worries
*** could an ONC be duplicated past a lambda replacement message
Picture an ONC which contains a symbol which is due to be replaced by
an incoming lambda message.  If this ONC is then duplicated *before*
the message is applied to someplace where the message will not reach,
then how will the message be applied?

* replace =requeue= as it violates consistency requirements
Violates the need for messages sent to a particular ONC to be received
in the order they are sent.

For now this has been fixed in the =fix= function (it now runs the
related ONC when such a situation is encountered), but a full solution
it still required.

* DONE ensure that referenced variables are never deleted
Somewhere there are poorly interleaved reference messages.

** Walking through file:test/examp-2.c execution with =gdb=.
| run (4,4)    |                           |                              |         |
| app_abs      |                           |                              |         |
|              | copy a to msg.cdr         | copy_ptr (3,2)               | (3,2)+1 |
|              | replace 2 with 4          | replace_ptr (3,3) with nil   | (3,3)-1 |
|              | replace 1 with 9          | replace_ptr (4,3) with (4,2) | (4,2)+1 |
|              |                           |                              | (4,3)-1 |
| λ app(4,2)   |                           |                              |         |
|              | copy down local pointer   | copy_ptr (3,2)               | (3,2)+1 |
|              | delete l_msg.mcdr         | delete_ptr (3,2)             | (3,2)-1 |
| run (3,2)+1  |                           |                              |         |
| run (3,3)-1  |                           | decrement msg to (3,2)       | (3,2)-1 |
| run (4,2)+1  |                           | increment msg to (4,1)       | (4,1)+1 |
| run (4,3)-1  |                           | decrement msg to (4,2)       | (4,2)-1 |
| run (3,2)+1  |                           |                              |         |
| λ msg (4,2)  |                           |                              |         |
|--------------+---------------------------+------------------------------+---------|
| λ app(4,1)   |                           |                              |         |
|              | copy down local pointer   | copy_ptr (3,2)               | (3.2)+1 |
|              | delete l_msg.mcdr         | delete_ptr (3,2)             | (3,2)-1 |
|              |                           |                              |         |
|              | copy target to cdr? (432) | copy_ptr (3,2)               | (3,2)+1 |
| λ app to nil |                           |                              |         |
|              |                           | delete_ptr (3,2)             | (3,2)-1 |
|              | cleanup target            | delete_ptr (3,2)             | (3,2)-1 |
|--------------+---------------------------+------------------------------+---------|
| run (3,2)-1  |                           |                              |         |
| run (3,2)-1  |                           |                              |         |
| run (4,1)+1  |                           | increment msg to (4,0)       | (4,0)+1 |
|              |                           |                              |         |

In the offset region above, the passing of a λ-message down an ONC
with *one* linked child, decrements the total number of references to
the target of the lambda message, while it should keep the original
value.

** Too many reference decrements in file:test/examp-1.c
Only when evaluated with =fix=, not when run with =run_down=.

Spot (7,6) has it's refs decremented down to 0 while it is referenced
by (7,7).  Thus, when (7,7) is duplicated into (8,2) or so, an open
space is requested and (7,6) *happens* to be returned, thus
overwriting it's value just before it's value is requested.

*** looking at senders of these messages w/printf debug
| message | from  | in      | why                   |
|---------+-------+---------+-----------------------|
| (7,7)-1 | (8,8) | app_abs | replace 1,2 with 9,10 |
| (7,6)-1 | (7,7) |         | propagate deletion    |
| (7,6)   | (7,6) |         | re-queue              |

*** analysis
in line 411 placed
#+begin_src C
    if(place.x == 7 && (place.y == 5 || place.y == 6))
      printf("(%d,%d)->%d\n", place.x, place.y, AT(place).mcar.car);
#+end_src

#+name: print-some-refs
#+begin_src sh
./test/examp-1.test |grep 5|cut -c8-
#+end_src

#+begin_src emacs-lisp :var messages=print-some-refs
  (format "%s"
           (let ((sum 1))
             (mapcar (lambda (new) (setq sum (+ sum new))) 
                     messages)))
#+end_src

ref counts for (7,6)
: (2 3 4 3 2 3 2 1 2 3 4 3 2 3 2 1 0 1 2 1 0)

ref counts for (7,5)
: (2 3 4 3 2 1 0 1 2 1 2 3 2 1 2 1 0 -1 -2 -3)

* DONE cleanup leftover lambdas in symbols
[[file:test/cbv.c::/*%20TODO:%20Need%20to%20cleanup%202-each%20extra%20lambdas%20and%20symbols%20*/][file:test/cbv.c::/* TODO: Need to cleanup 2-each extra lambdas and symbols */]]

* ensure that free variables don't clash
variable renaming on application may not be implemented/working

* DONE lambdas are /evaporating/ through application to nil
Given that we're using =nil= for the ends of lists, we need to keep
lambdas from applying themselves to =nil= so they don't evaporate.

* y-comb.c evaluation order of operations
Will need some control over order of application.

See many papers here.
http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html

| call by value | only values substituted into a lambda |
| normal order  | always work with the outermost redex  |
| call by name  | dont dive into a lambda               |

- Haskell is /call by name/ with laziness which makes it call by need.
- Java, C, ML etc... are all /call by value/

For now lets look at call by value.

** DONE use the cdr of lambda pointers to track locking information
currently a lambda expression holds something like
:   +-----------------------+
:   | λ | int id | empty    |
:   +-----------------------+
perhaps the could be replaced with
:   +-----------------------+
:   | λ | int id | locked   |
:   +-----------------------+

This way λ-messages propagating through ONC structures could carry
updating locking information down the structure.

** application abstractions
: app_abs(4,0) ((#L1 (#S0 (#L2 ((#S1 #S1) #S2)))) (#L1 (#S0 (#L2 ((#S1 #S1) #S2)))))
: app_abs(4,2) ((#L0 ((#S0 (#L2 ((#S1 #S1) #S2))))) (#L3 (#L4 ((= 0 #S4) 1 (* #S4 (#S3 (- 1 #S4)))))))
: app_abs(4,7) ((#L3 (#L4 ((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) (#L2 ((#S1 #S1) #S2)))

** raw expressions at place
#+begin_src sh
  ./test/y-comb.test -v|grep expr|sed 's/ )/)/g'|uniq|cut -c11-
#+end_src

: ((((#L0 (#L1 (#S0 #L2 ((#S1 #S1) #S2))) (#L1 (#S0 #L2 ((#S1 #S1) #S2)))) (#L3 (#L4 ((= 0 #S4) 1 (* #S4 (#S3 (- 1 #S4))))))) 2))
: ((((((#S0 #L2 ((#S1 #S1) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((#S1 #S1) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((#S0 #L2 ((#S1 #S1) #S2))) #S1) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((#S0 #L2 ((#S1 #S1) #S2))) ((#S0 #S0 (( #S1) #S2)))) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((((((#S0 #S0 (( #S1) #S2))))) #L2 ((#S1 #S1) #S2))) ((#S0 #S0 (( #S1) #S2)))) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((((((#S0 #S0 (( #S1) #S2))))) #L2 ((#S1 #S1) #S2))) (((#S0 #S0 (( #S1) #S2))))) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((((((#S0 ((((#S0 #S0 (( #S1) #S2))))) (( #S1) #S2))))) #L2 ((#S1 #S1) #S2))) (((#S0 ((((#S0 #S0 (( #S1) #S2))))) (( #S1) #S2))))) #S2))))) 2))

* play with y-comb in scheme
#+begin_src scheme
  ;; most naive, just duplicate function and pass it to itself
  (((lambda (f) (lambda (n) (if (zero? n) 1 (* n ((f f) (1- n))))))
    (lambda (f) (lambda (n) (if (zero? n) 1 (* n ((f f) (1- n)))))))
   4)
  
  ;; using a Y-combinator to handle function duplication
  (((lambda (m)
      ((lambda (f) (m (lambda (a) ((f f) a))))
       (lambda (f) (m (lambda (a) ((f f) a))))))
    (lambda (r) (lambda (n) (if (zero? n) 1 (* n (r (1- n))))))) 4)
#+end_src

* should implement a duplicate message type
* DONE unpack lambdas not just applications of curried functions
When replacing the pointer to the lambda application, don't point its
car at the body and its cdr at the following expressions, rather
follow the body down to its end, and point /that/ at the following
expressions.

Note, if the extension of the end of the body of the lambda expression
is done /before/ the lambda application message is sent, then the
message will /leak/ through to the following expressions.  So either,
1. the extension must be made /after/ the lambda application message
   has finished propagating or
2. the lambda application message must expire at the end of the body,
   which could be done through either counting, or some marker at the
   end of the body
3. even better, there could be an "extension" message, which could
   propagate down the structure after the lambda application message,
   ensuring that it is applied immediately after lambda replacement.

** DONE implement option (3) above with "extension" messages
* variables in the =run= function
** before
:                  ((λ1 s1 ...) a b ...)
: 
:                     
:                     
:         +--------+--------+          +--------+--------+          +--------+--------+                   
:         |1       |2       |          |3       |4       |          |5       |6       |
:         |        |       -+--------> |   a    |       -+--------> |   b    |   ...  |
:         |   |    |        |          |        |        |          |        |        |
:         +---+----+--------+          +--------+--------+          +--------+--------+
:             |                                                                     
:             |                                                                     
:             v                                                                     
:         +--------+--------+          +--------+--------+                          
:         |7       |8       |          |9       |10      |                          
:         |   λ1   |       -+--------> |   s1   |   ...  |                          
:         |        |        |          |        |        |                          
:         +--------+--------+          +--------+--------+

** goes to
:   +--+-+         ((λ1 s1 ...) a b ...)
:   |λ1|a|---+
:   +--+-+   |          +------------------------------------------------+
:            v          |                                                v
:         +--------+----+---+          +--------+--------+          +--------+--------+
:         |1       |2   |   |          |3       |4       |          |5       |6       |
:         |        |        |          |   a    |       -+--------> |   b    |   ...  |
:         |   |    |        |          |        |        |          |        |        |
:         +---+----+--------+          +--------+--------+          +--------+--------+
:             |              
:             +----------------------------+
:                                          v
:         +--------+--------+          +--------+--------+                          
:         |7       |8       |          |9       |10      |                          
:         |   λ1   |       -+--------> |   s1   |   ...  |                          
:         |        |        |          |        |        |                          
:         +--------+--------+          +--------+--------+

Steps
1. make new msg
2. copy λ1 to msg.car
3. copy a to msg.cdr
4. replace (1,2) with (9,10)
5. msg goes to 1
6. replace end of 10 with 4

| functions | refs                                                       |
|-----------+------------------------------------------------------------|
| copy      | duplicates a pointer, if(pointer.hdr==LOCAL) target.refs++ |
| delete    | deletes a pointer, if(pointer.hdr==LOCAL) target.refs--    |

* dealing with "global" variables and environments
need to address this eventually, points to keep in mind
- build-ins which should be provided by the medium itself
- software transactional memory for widely referenced values
- the environment pointers from previous iterations

* DONE need to figure out how to un-shell results
When a function is applied to arguments, it must then /emerge/ from
the list enclosing the function and arguments.
: (+ 1 1) => 2
not
: (+ 1 1) => (2)

Some sort of new =PROMOTE= or =UNPACK= header argument.

* DONE better reading/writing between strings and ONCS
specifically currently it is necessary to include far too many
parenthesis specifying the linking order for lists, e.g., what should
be written as =(1 2 3 4 5)= must be written as =(1 (2 (3 (4 (5)))))=.

* direct debug output to STDERR
* DONE leftover lambda and (0,0) messages
For some reason after running some applications there are leftover
lambdas and messages sent to (0,0).

* DONE reading strings into ONCS
For example.
: (#L#S1 (#S1 #S1)) (1 (2 3))

* at some point replace all structs with binary data
  :PROPERTIES:
  :CUSTOM_ID: no-structs
  :END:
apparently every element of a struct is as large as the largest
structure, better to just use binary blobs and do my own pointer
arithmetic (macros should suffice).

* DONE should probably make =msg= its own structure
It should hold two pointers rather than just a single pointer.

once things are working we can replace this with something more
efficient (see [[#no-structs]]).

* DONE how to include a library that needs to create state
i.e., a header file that creates its own local variables... should it
have an init function?

just declare in both the .h and .c files
- oncs.h
  #+begin_src C
  /* global state */
  extern onc world[SIZE][SIZE];
  extern msg queue[];
  extern int qbeg, qend;
  #+end_src

- oncs.c
  #+begin_src C
  onc world[SIZE][SIZE];
  msg queue[QLENGTH];
  int qbeg, qend = 0;
  #+end_src

* other message types
- refresh (or some such) to indicate to a higher level portion of your
  structure that you have changed
- ready to be applied (for when I become a lambda and want to let the
  next level up know) -- although this would require up-pointers

* is it worth holding pointers to higher level
similar to the =env= pointer in earlier instantiating

* reverse lambdas -- matching lambdas with their applications
while
: (\lambda ..tons of stuff..)(argument)
seems like it would require lots of message passing to apply, the same
isn't true for
: (...tons of stuff...\lambda)(argument)

the key is just to start the application from the next level up

* eventually replace the global queue with something that lives in ONC world
* COMMENT Publishing
This code is used to publish this page to the =cs.unm.edu= webserver.
#+begin_src emacs-lisp :results silent
  (setq oncs-dir (file-name-directory (or load-file-name buffer-file-name)))
  (setq oncs-server "moons.cs.unm.edu") ;; was kenworth.cs.unm.edu
  (unless (boundp 'org-publish-project-alist)
    (setq org-publish-project-alist nil))
  ;; the main html page
  (add-to-list 'org-publish-project-alist
               `("oncs-html"
                 :section-numbers nil
                 :table-of-contents nil
                 :base-directory ,oncs-dir
                 :include ("README")
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/"
                                                oncs-server)
                 :publishing-function org-publish-org-to-html
                 :style "<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/
    pre{display:table-cell;background:#232323; color:#e6e1dc;}
    #content{max-width:1000px;margin:auto;} body{ font-size:small; } table{ font-size:small; }
    .outline-text-2{margin-left:2em;}.outline-text-3{margin-left:3em;}
    .title  { text-align: center; }
    p.verse { margin-left: 3% }
    p { text-align: justify }
    table { border-collapse: collapse; }
    td, th { vertical-align: top; }
    dt { font-weight: bold; }
    div.figure { padding: 0.5em; }
    div.figure p { text-align: center; }
    .linenr { font-size:smaller }
    #postamble { color: gray; padding-top: 2em; font-size: 0.75em; }
    /*]]>*/-->
  </style>"))
  ;; the contents of the base directory
  (add-to-list 'org-publish-project-alist
               `("oncs-data"
                 :base-directory ,oncs-dir
                 :include ("COPYING")
                 :base-extension "h\\|c\\|txt\\|lisp"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/"
                                                oncs-server)
                 :publishing-function org-publish-attachment))
  (add-to-list 'org-publish-project-alist
               `("oncs-src"
                 :base-directory ,(expand-file-name "src" oncs-dir)
                 :base-extension "h\\|c\\|txt\\|lisp"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/src/"
                                                oncs-server)
                 :publishing-function org-publish-attachment))
  (add-to-list 'org-publish-project-alist
               `("oncs-test"
                 :base-directory ,(expand-file-name "test" oncs-dir)
                 :base-extension "h\\|c\\|txt\\|lisp"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/test/"
                                                oncs-server)
                 :publishing-function org-publish-attachment))
  ;; a single combined project to publish both html and supporting materials
  (add-to-list 'org-publish-project-alist
               '("oncs" :components ("oncs-html" "oncs-data" "oncs-src" "oncs-test")))
#+end_src
