# -*- mode:org -*-

* TODO cleanup leftover lambdas in symbols
[[file:test/cbv.c::/*%20TODO:%20Need%20to%20cleanup%202-each%20extra%20lambdas%20and%20symbols%20*/][file:test/cbv.c::/* TODO: Need to cleanup 2-each extra lambdas and symbols */]]

* TODO ensure that free variables don't clash
variable renaming on application may not be implemented/working

* DONE lambdas are /evaporating/ through application to nil
Given that we're using =nil= for the ends of lists, we need to keep
lambdas from applying themselves to =nil= so they don't evaporate.

* y-comb.c evaluation order of operations
Will need some control over order of application.

See many papers here.
http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html

| call by value | only values substituted into a lambda |
| normal order  | always work with the outermost redex  |
| call by name  | dont dive into a lambda               |

- Haskell is /call by name/ with laziness which makes it call by need.
- Java, C, ML etc... are all /call by value/

For now lets look at call by value.

** DONE use the cdr of lambda pointers to track locking information
currently a lambda expression holds something like
:   +-----------------------+
:   | λ | int id | empty    |
:   +-----------------------+
perhaps the could be replaced with
:   +-----------------------+
:   | λ | int id | locked   |
:   +-----------------------+

This way λ-messages propagating through ONC structures could carry
updating locking information down the structure.

** application abstractions
: app_abs(4,0) ((#L1 (#S0 (#L2 ((#S1 #S1) #S2)))) (#L1 (#S0 (#L2 ((#S1 #S1) #S2)))))
: app_abs(4,2) ((#L0 ((#S0 (#L2 ((#S1 #S1) #S2))))) (#L3 (#L4 ((= 0 #S4) 1 (* #S4 (#S3 (- 1 #S4)))))))
: app_abs(4,7) ((#L3 (#L4 ((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) (#L2 ((#S1 #S1) #S2)))

** raw expressions at place
#+begin_src sh
  ./test/y-comb.test -v|grep expr|sed 's/ )/)/g'|uniq|cut -c11-
#+end_src

: ((((#L0 (#L1 (#S0 #L2 ((#S1 #S1) #S2))) (#L1 (#S0 #L2 ((#S1 #S1) #S2)))) (#L3 (#L4 ((= 0 #S4) 1 (* #S4 (#S3 (- 1 #S4))))))) 2))
: ((((((#S0 #L2 ((#S1 #S1) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((#S1 #S1) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((#S0 #L2 ((#S1 #S1) #S2))) #S1) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((#S0 #L2 ((#S1 #S1) #S2))) ((#S0 #S0 (( #S1) #S2)))) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((((((#S0 #S0 (( #S1) #S2))))) #L2 ((#S1 #S1) #S2))) ((#S0 #S0 (( #S1) #S2)))) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((((((#S0 #S0 (( #S1) #S2))))) #L2 ((#S1 #S1) #S2))) (((#S0 #S0 (( #S1) #S2))))) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((((((#S0 ((((#S0 #S0 (( #S1) #S2))))) (( #S1) #S2))))) #L2 ((#S1 #S1) #S2))) (((#S0 ((((#S0 #S0 (( #S1) #S2))))) (( #S1) #S2))))) #S2))))) 2))

* play with y-comb in scheme
#+begin_src scheme
  ;; most naive, just duplicate function and pass it to itself
  (((lambda (f) (lambda (n) (if (zero? n) 1 (* n ((f f) (1- n))))))
    (lambda (f) (lambda (n) (if (zero? n) 1 (* n ((f f) (1- n)))))))
   4)
  
  ;; using a Y-combinator to handle function duplication
  (((lambda (m)
      ((lambda (f) (m (lambda (a) ((f f) a))))
       (lambda (f) (m (lambda (a) ((f f) a))))))
    (lambda (r) (lambda (n) (if (zero? n) 1 (* n (r (1- n))))))) 4)
#+end_src

* should implement a duplicate message type
* unpack lambdas not just applications of curried functions
* variables in the =run= function
:                  ((λ1 s1 ...) a b ...)
: 
:                     
:                     
:         +--------+--------+          +--------+--------+          +--------+--------+                   
:         |1       |2       |          |3       |4       |          |5       |6       |
:         |        |       -+--------> |   a    |       -+--------> |   b    |   ...  |
:         |   |    |        |          |        |        |          |        |        |
:         +---+----+--------+          +--------+--------+          +--------+--------+
:             |                                                                     
:             |                                                                     
:             v                                                                     
:         +--------+--------+          +--------+--------+                          
:         |7       |8       |          |9       |10      |                          
:         |   λ1   |       -+--------> |   s1   |   ...  |                          
:         |        |        |          |        |        |                          
:         +--------+--------+          +--------+--------+

goes to

:   +--+-+         ((λ1 s1 ...) a b ...)
:   |λ1|a|---+
:   +--+-+   |          +------------------------------------------------+
:            v          |                                                v
:         +--------+----+---+          +--------+--------+          +--------+--------+
:         |1       |2   |   |          |3       |4       |          |5       |6       |
:         |        |        |          |   a    |       -+--------> |   b    |   ...  |
:         |   |    |        |          |        |        |          |        |        |
:         +---+----+--------+          +--------+--------+          +--------+--------+
:             |              
:             +----------------------------+
:                                          v
:         +--------+--------+          +--------+--------+                          
:         |7       |8       |          |9       |10      |                          
:         |   λ1   |       -+--------> |   s1   |   ...  |                          
:         |        |        |          |        |        |                          
:         +--------+--------+          +--------+--------+

Steps
1. make new msg
2. copy λ1 to msg.car
3. copy a to msg.cdr
4. replace 2 with 4
5. replace 1 with 8
6. msg goes to 1

| functions | refs                                                       |
|-----------+------------------------------------------------------------|
| copy      | duplicates a pointer, if(pointer.hdr==LOCAL) target.refs++ |
| delete    | deletes a pointer, if(pointer.hdr==LOCAL) target.refs--    |

* dealing with "global" variables and environments
need to address this eventually, points to keep in mind
- build-ins which should be provided by the medium itself
- software transactional memory for widely referenced values
- the environment pointers from previous iterations

* DONE need to figure out how to un-shell results
When a function is applied to arguments, it must then /emerge/ from
the list enclosing the function and arguments.
: (+ 1 1) => 2
not
: (+ 1 1) => (2)

Some sort of new =PROMOTE= or =UNPACK= header argument.

* DONE better reading/writing between strings and ONCS
specifically currently it is necessary to include far too many
parenthesis specifying the linking order for lists, e.g., what should
be written as =(1 2 3 4 5)= must be written as =(1 (2 (3 (4 (5)))))=.

* direct debug output to STDERR
* DONE leftover lambda and (0,0) messages
For some reason after running some applications there are leftover
lambdas and messages sent to (0,0).

* DONE reading strings into ONCS
For example.
: (#L#S1 (#S1 #S1)) (1 (2 3))

* at some point replace all structs with binary data
  :PROPERTIES:
  :CUSTOM_ID: no-structs
  :END:
apparently every element of a struct is as large as the largest
structure, better to just use binary blobs and do my own pointer
arithmetic (macros should suffice).

* DONE should probably make =msg= its own structure
It should hold two pointers rather than just a single pointer.

once things are working we can replace this with something more
efficient (see [[#no-structs]]).

* DONE how to include a library that needs to create state
i.e., a header file that creates its own local variables... should it
have an init function?

just declare in both the .h and .c files
- oncs.h
  #+begin_src C
  /* global state */
  extern onc world[SIZE][SIZE];
  extern msg queue[];
  extern int qbeg, qend;
  #+end_src

- oncs.c
  #+begin_src C
  onc world[SIZE][SIZE];
  msg queue[QLENGTH];
  int qbeg, qend = 0;
  #+end_src

* other message types
- refresh (or some such) to indicate to a higher level portion of your
  structure that you have changed
- ready to be applied (for when I become a lambda and want to let the
  next level up know) -- although this would require up-pointers

* is it worth holding pointers to higher level
similar to the =env= pointer in earlier instantiating

* reverse lambdas -- matching lambdas with their applications
while
: (\lambda ..tons of stuff..)(argument)
seems like it would require lots of message passing to apply, the same
isn't true for
: (...tons of stuff...\lambda)(argument)

the key is just to start the application from the next level up

* eventually replace the global queue with something that lives in ONC world
* COMMENT Publishing
This code is used to publish this page to the =cs.unm.edu= webserver.
#+begin_src emacs-lisp :results silent
  (setq oncs-dir (file-name-directory (or load-file-name buffer-file-name)))
  (setq oncs-server "moons.cs.unm.edu") ;; was kenworth.cs.unm.edu
  (unless (boundp 'org-publish-project-alist)
    (setq org-publish-project-alist nil))
  ;; the main html page
  (add-to-list 'org-publish-project-alist
               `("oncs-html"
                 :section-numbers nil
                 :table-of-contents nil
                 :base-directory ,oncs-dir
                 :include ("README")
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/"
                                                oncs-server)
                 :publishing-function org-publish-org-to-html
                 :style "<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/
    pre{display:table-cell;background:#232323; color:#e6e1dc;}
    #content{max-width:1000px;margin:auto;} body{ font-size:small; } table{ font-size:small; }
    .outline-text-2{margin-left:2em;}.outline-text-3{margin-left:3em;}
    .title  { text-align: center; }
    p.verse { margin-left: 3% }
    p { text-align: justify }
    table { border-collapse: collapse; }
    td, th { vertical-align: top; }
    dt { font-weight: bold; }
    div.figure { padding: 0.5em; }
    div.figure p { text-align: center; }
    .linenr { font-size:smaller }
    #postamble { color: gray; padding-top: 2em; font-size: 0.75em; }
    /*]]>*/-->
  </style>"))
  ;; the contents of the base directory
  (add-to-list 'org-publish-project-alist
               `("oncs-data"
                 :base-directory ,oncs-dir
                 :include ("COPYING")
                 :base-extension "h\\|c\\|txt\\|lisp"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/"
                                                oncs-server)
                 :publishing-function org-publish-attachment))
  (add-to-list 'org-publish-project-alist
               `("oncs-src"
                 :base-directory ,(expand-file-name "src" oncs-dir)
                 :base-extension "h\\|c\\|txt\\|lisp"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/src/"
                                                oncs-server)
                 :publishing-function org-publish-attachment))
  (add-to-list 'org-publish-project-alist
               `("oncs-test"
                 :base-directory ,(expand-file-name "test" oncs-dir)
                 :base-extension "h\\|c\\|txt\\|lisp"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/test/"
                                                oncs-server)
                 :publishing-function org-publish-attachment))
  ;; a single combined project to publish both html and supporting materials
  (add-to-list 'org-publish-project-alist
               '("oncs" :components ("oncs-html" "oncs-data" "oncs-src" "oncs-test")))
#+end_src
