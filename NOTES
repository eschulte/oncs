# -*- mode:org -*-
#+Options: ^:nil

* another reference counting bug
file:test/fact-o-4.c throws an error depending on the =SIZE=.
| SIZE | errors |
|------+--------|
| 16   | yes    |
| 24   | no     |
| 32   | yes    |

Also, in many tests ONCS may be seen disappearing briefly and then
reappearing.  Interleaved ref+ and ref- messages must be to blame.

Also, file:test/fact-2.c errors out when =SIZE= is 8.

In file:test/examp-1.c you'll notice a λ at (3,2) disappears briefly
and then reappears before it is done being used.

* debugging duplicate messages
: break run if (world[place.x][place.y].mcar.hdr != 0)

probably need to switch from pushing to appending
: Q[2]:(3,3)r(2,3)r
:      0   1   2   3   4   5   6   7   8   9
:  0                                         
:  1                                         
:  2          _1_                            
:  3          ^1_ l1s                        
:  4              ^1^                        
:  5                  L1^ ^1_                
:  6                                         
:  7                                         
:  8                                         
:  9                                         
: ERROR: can't propagate down bottomed out ONC.
: expr(5,5):(#L1 (#l0 #S1) ))
: hash:4c564098
: (3,3) depth(1) value=(3,0,0)

* anatomy of duplicate and replace messages
Duplicate
| msg.place    | coord of to be duplicated                  |
| msg.mcar.hdr | DUPLICATE or LDUPLICATE                    |
| msg.mcar     | coord of target of duplication             |
| msg.mcdr.hdr | dir-length (on way down we append to dirs) |
| msg.mcdr.car | number of steps to follow down structure   |
| msg.mcdr.cdr | bit-array specifying LEFT/RIGHT path       |
|              | to take traversing down the linked ONC     |
|              | structure starting at the target of        |
|              | duplication                                |

Replace
| msg.place    | target of duplication                    |
| msg.mcar.hdr | REPLACE                                  |
| msg.mcar.car | number of steps to follow down structure |
| msg.mcar.cdr | bit-array specifying LEFT/RIGHT path     |
| msg.mcdr     | contents                                 |

* Pthreads C implementation
All threads share the same address space, and each thread has its own
thread ID.  So the solution would be to make one world and message
queue per thread, and index those worlds and queues behind the thread
IDs.

* fit long coordinates into pointers
New long coordinates will stretch across multiple worlds.

Will have to fit two integers into one integer with bit-shifting
magic.

** implementation -- packing chars into ints
#+begin_src C :results output
  int x = 1024;
  char* bits = (char*)&x;
  printf("%06d -> [%02d][%02d]\n", x, bits[0], bits[1]);
  bits[0] = 8; bits[1] = 9;
  printf("%06d -> [%02d][%02d]\n", x, bits[0], bits[1]);
  char c1, c2;
  c1 = (char)x;
  c2 = (x>>8) & 0x7F;
  printf("%06d -> [%02d][%02d]\n", x, c1, c2);
  printf("%06d -> [%02d][%02d]\n", x, c1, c2);
  c1 = 0;
  c2 = 4;
  x = (c1 | c2 << 8);
  printf("%06d -> [%02d][%02d]\n", x, c1, c2);
#+end_src

#+RESULTS:
: 001024 -> [00][04]
: 002312 -> [08][09]
: 002312 -> [08][09]
: 002312 -> [08][09]
: 001024 -> [00][04]

** implementation -- bit arrays
*** simple
#+begin_src C
  int x, i;
  x = 4;
  printf("poping\n");
  for(i=0;i<4;i++){
    /* pop */
    printf("x=%d, x[%d]=%d\n", x, i, (x & 1));
    x=x>>1;
  }
  printf("pushing\n");
  for(i=0;i<4;i++){
    /* push */
    if(i==1) x = x | 1;
    printf("x=%d, x[%d]=%d\n", x, i, (x & 1));
    x=x<<1;
   }
#+end_src

#+RESULTS:
#+begin_example
poping
x=4, x[0]=0
x=2, x[1]=0
x=1, x[2]=1
x=0, x[3]=0
pushing
x=0, x[0]=0
x=1, x[1]=1
x=2, x[2]=0
x=4, x[3]=0
#+end_example

*** LIFO
#+begin_src C
  int x, i, y;
  x=0;
  printf("pushing 1010110\n");
  x=x<<1;
  x=x|1;
  x=x<<1;
  x=x|0;
  x=x<<1;
  x=x|1;
  x=x<<1;
  x=x|0;
  x=x<<1;
  x=x|1;
  x=x<<1;
  x=x|1;
  x=x<<1;
  x=x|0;
  printf("poping 0110101\n");
  for(i=0;i<7;i++){
    y=x&1;
    x=x>>1;
    printf("%d", y);
   }
  printf("\n");
#+end_src

#+RESULTS:
: pushing 1010110
: poping 0110101
: 0110101

*** FIFO
#+begin_src C
  int x, i, y;
  i=x=0;
  printf("2^=%d 2^1=%d 2^2=%d\n",
         1<<0, 1<<1, 1<<2);
  printf("appending 1010110\n");
  x=x|1<<i;
  i++;
  printf("x=%d\n", x);
  x=x|0<<i;
  i++;
  printf("x=%d\n", x);
  x=x|1<<i;
  i++;
  printf("x=%d\n", x);
  x=x|0<<i;
  i++;
  printf("x=%d\n", x);
  x=x|1<<i;
  i++;
  printf("x=%d\n", x);
  x=x|1<<i;
  i++;
  printf("x=%d\n", x);
  x=x|0<<i;
  i++;
  printf("x=%d\n", x);
  printf("poping 1010110\n");
  for(i=0;i<7;i++){
    y=x&1;
    x=x>>1;
    printf("%d", y);
   }
  printf("\n");
#+end_src

#+RESULTS:
#+begin_example
2^=1 2^1=2 2^2=4
appending 1010110
x=1
x=1
x=5
x=5
x=21
x=53
x=53
poping 1010110
1010110
#+end_example

* make ONC duplication message based
So =duplicate_ptr= should not set a value directly, but should rather
dispatch messages out to the argument to then carry it's contents to
the location.

We can stream onc structures across boards requested with a single
=Dup= message and streamed with many =Rep= messages.
: +--------------+          +--------------+
: |   Board A    |   Dup    |   Board B    |
: |      <-------+----------+---           |
: |              |          |              |
: |      --------+----------+-->           |
: |              |   Rep    |              |
: +--------------+          +--------------+

- *all* messages (both intra- and inter-board) will have the same form
- this form will use long-form coordinates, specifically =[X,Y,x,y:bin-array]=
- once received at an ONC these messages will fit into the mcar and
  mcdr pointers

Example messages with contents:
- request duplication of E,F,g,h to A,B,c,d:01001
  | coord    | E,F,g,h:0 |
  | mcar.hdr | Dup       |
  | mcar.car | A         |
  | mcar.cdr | B         |
  | mcar.hdr | 01001     |
  | mcdr.car | c         |
  | mcdr.cdr | d         |
- duplication to A,B,c,d:01001 as stored in the ONC at E,F,g,h
  | mcar.hdr | Dup       |
  | mcar.car | A         |
  | mcar.cdr | B         |
  | mcar.hdr | 01001     |
  | mcdr.car | c         |
  | mcdr.cdr | d         |
- in-flight ONC data from E,F,g,h to A,B,c,d:01001
  | coord    | A,B,c,d:01001       |
  | mcar.hdr | AT(E,F,g,h).car.hdr |
  | mcar.car | AT(E,F,g,h).car.car |
  | mcar.cdr | AT(E,F,g,h).car.cdr |
  | mcdr.hdr | AT(E,F,g,h).cdr.hdr |
  | mcdr.car | AT(E,F,g,h).cdr.car |
  | mcdr.cdr | AT(E,F,g,h).cdr.cdr |
  if the =AT(E,F,g,h).cdr.hdr==LOCAL= then that portion will be
  | mcdr.hdr | NEW |
  | mcdr.car |     |
  | mcdr.cdr |     |
  where =NEW= will be a header indicating that a new empty ONC should
  be created and pointed to using =open_space=.

** thoughts
1. A Dup message is sent from X on Board B to Y on Board A
   :     +-------+-----+
   :     | Dup   | A,Y |
   :     +-------+-----+
   :     | From: |     |
   :     | B,X   |     |
   :     +-----+-------+
2. When this message is received at Y, a return message is sent
   holding the contents of Y.  The contents of links are left empty,
   and are filled at the destination site with the output of the
   =open_space= function.
   :     +-----+-------+
   :     | Rep | B,X   |
   :     +-----+-------+
   :     | A,Y | A,y   |
   :     | car | cdr   |
   :     +-----+-------+
3. In addition, Dup messages are propagated down through the local
   refs in Y traversing the whole ONC structure.
   :     +-----+-------+   +-----+-------+
   :     | Dup | A,Y.0 |   | Dep | A,Y.1 |
   :     +-----+-+-----+   +-----+-+-----+
   :     | From: |     |   | From: |     |
   :     | B,X.0 |     |   | B,X.1 |     |
   :     +-------+-----+   +-------+-----+
4. These children send back Rep message to B,X
   :     +-----+-------+   +-----+-------+
   :     | Rep | B,X.0 |   | Rep | B,X.1 |
   :     +-----+-------+   +-----+-------+
   :     |A,Y.0| A,Y.0 |   |A,Y.1| A,Y.1 |
   :     | car | cdr   |   | car | cdr   |
   :     +-----+-------+   +-----+-------+
   Where the binary string at the end of the address (e.g., =B,X.010=)
   is used to indicate which paths to take at forks in the binary tree
   structure of the receiving ONC.  The following cases are used to
   consume the binary routing instructions.
   - B,X is empty → place contents in B,X
   - B,X is full and only has 1 pointer → set address to that pointer
     and forward the message there
   - B,X has two pointers → consume the first byte off the binary
     string, if 0 forward the message to car if 1 to cdr

So these messages would have to hold,
- hdr
- long-coord (X,Y,x,y,int)
- two pointers

Questions:
- should there be a new message type, or should all messages bloat?
- should all coords be replaced with long coords?
- should long coords include these integer-size binary offsets in all cases?
- if ONCS will keep the same two-message slots for normal messages can
  Dup messages fit?

Solution:
- *all* messages will have the same form
- this form will use long-form coordinates, specifically =[X,Y,x,y:bin-array]=
- once received at an ONC these messages will fit into the mcar and
  mcdr pointers

Examples:
- request duplication of E,F,g,h to A,B,c,d:01001
  | coord    | E,F,g,h:0 |
  | mcar.hdr | Dup       |
  | mcar.car | A         |
  | mcar.cdr | B         |
  | mcar.hdr | 01001     |
  | mcdr.car | c         |
  | mcdr.cdr | d         |
- duplication to A,B,c,d:01001 as stored in the ONC at E,F,g,h
  | mcar.hdr | Dup       |
  | mcar.car | A         |
  | mcar.cdr | B         |
  | mcar.hdr | 01001     |
  | mcdr.car | c         |
  | mcdr.cdr | d         |
- in-flight ONC data from E,F,g,h to A,B,c,d:01001
  | coord    | A,B,c,d:01001       |
  | mcar.hdr | AT(E,F,g,h).car.hdr |
  | mcar.car | AT(E,F,g,h).car.car |
  | mcar.cdr | AT(E,F,g,h).car.cdr |
  | mcdr.hdr | AT(E,F,g,h).cdr.hdr |
  | mcdr.car | AT(E,F,g,h).cdr.car |
  | mcdr.cdr | AT(E,F,g,h).cdr.cdr |
  if the =AT(E,F,g,h).cdr.hdr==LOCAL= then that portion will be
  | mcdr.hdr | NEW |
  | mcdr.car |     |
  | mcdr.cdr |     |
  where =NEW= will be a header indicating that a new empty ONC should
  be created and pointed to using =open_space=.

* would it be possible to limit the number of variable
∀ n∈N ∃ a λ-expression l s.t. l requires >n symbols.

Is there a way to make this not true, e.g., use something /spatial/ to
represent symbols.

* no longer safe to assume all neighboring ONCs are immediately accessible
On both the IXM and the GPU, *all* access to other ONCs must be made
asynchronous and message based.
:              Inter-world Communication
:                            +--------------+
:   coord={X,Y,x,y}          |              |
:     where                  |  grid world  |
:       X=rel-inter          |              |
:       Y=rel-inter          |              |
:       x=absolute-intra     |              |
:       y=absolute-intra     +--------------+
:                                          
:       +--------------+     +--------------+
:       |              |     |              |
:       |  grid world  |     |  grid world  |
:       |              | <=> |              |
:       |              |     |              |
:       |              |     |              |
:       +--------------+     +--------------+

Mechanisms
- sending, receiving and propagating messages with adjustments to the
  global X,Y relative parameters

Messages
- require a message to access the contents of an ONC.

Actions that require the state of remote ONCS
- =duplicate_ptr= on a LOCAL pointer requires one remote ONC at a
  time, maybe many over recursive calls
- checking if a location satisfies =argument_p= or =value_p=, again
  with possible recursive calls
- =ptr_to_string= may link off-world
  (should be able to run recursive calls off-world)
- =onc_to_string= may link off-world
- =app_abs= may need to read values from
  - AT(place).car
  - AT(place).cdr
  - AT(place).car.cdr
- =run= may need values from
  - AT(place).car
  - AT(place).cdr

Maybe before running an action such as checking for λ-application, a
series of messages can be sent out holding functions to run on linked
ONCS (e.g., value_p of coord), and the results can then be saved
locally to the acting ONC.  Only when all required values are saved
locally will the action actually be run.

* IXM
1. Install the cross-compilation suite using software and instructions
   from http://robust.cs.unm.edu/wiki/SFB/Minimal_Linux_Install
   (had to remove =-Wall= from the compilation flags)

2. Build a test sketch with the instructions from
   http://robust.cs.unm.edu/wiki/SFB/Compiling_Your_First_Sketch_With_Make
   (working, relatively painless)

3. Stub out the shell of a sketch for ONC evaluation, including
   loading the file:src/oncs.h header file and write the Makefile
   rules to compile and burn the sketch.
   
   Alright, it is at least trying to compile, but either some options
   (like maybe =-Wall=) or the fact that we're now using a C++
   compiler are causing errors.

** moving into IXM ecosystem [0/5]
*** TODO using the IXM main loop
*** TODO saving the world/queue into IXM memory
*** TODO convert between ONC/IXM messages
*** TODO find open space on other boards
*** TODO check values on other boards
* try out call by need rather than call by value
Rather than copying arguments into the bodies of λ-expressions, just
copy in a link to the original.  Then when it is updated in place, it
will be updated for all.  This will allow for more efficient
execution.

Also, need to check how this variant of call-by-name will be different
from call-by-value... how will laziness affect the semantics, e.g., do
I need a different Y-combinator?

** call-by-name in action
:                                              Locked until recieves a DUP
:                                           Does not send REP until it is a value
:                                                     +---
:                                         DUP         |   \--+
: - replace x with locked DUP     +-----------------> | arg  |
: - unlock DUP and send DUP when  |                   +------+
:   used in an app_abs            |                    |
:                                 |                    |
:              /---------         |        REP         |
:          /---  λx.     \------\   <------------------+
:        +-                      \
:        |       /---+            \
:        |      /    |             \
:        +------     \             --
:                     |        ---/
:                     +-------/
:                              
:                  (λ x (... x ... x ...)) (arg)

** Actions for call-by-name
1. The outermost λ-application is always applied first, arguments are
   *not* evaluated.  The locking here may have to be /more/
   restrictive than in call-by-value, as we want to enforce laziness.

2. When arguments are substituted into the body of a λ-app, we'll just
   drop links to the original location of the argument, and unlock any
   λ's contained therein.

   There will however have to be some duplication, e.g., if an
   argument evaluates to a λ-app, after it is evaluated and copied in,
   the result must be duplicated for each insertion... as they may be
   passed different argument.

** Tasks [1/4]
Will have to
- [ ] wrap all relevant code in =#ifdef= declarations to compile out
  different evaluation strategies
- [X] update the =value_p= function to allow un-applied λ-apps to be
  counted as value arguments (rename to =argument_p=).
- [ ] update mechanism used in =lambda_app= to insert locked DUPs.
- [ ] update the DUP rule to evaluate before sending a response.
- [ ] update the app_abs rule to unlock relevant locked DUPS.
- [ ] update all tests which currently rely on call-by-value
  evaluation order.

* DONE show_queue has an error in the for loop
switch to other loop cycling for loops found elsewhere in the code

* HOLD openCL
  - State "HOLD"       from ""           [2012-05-01 Tue 17:01] \\
    do this *after* IXM, as it will be more difficult, and my intel GPU does not support
- this is the [[http://opencl.codeplex.com/wikipage?title=OpenCL%20Tutorials%20-%201][most promising tutorial]].

Installed
: pacman -S libcl opencl-headers

the following now compiles and runs
#+begin_src C
#include <CL/opencl.h>

void main(){ puts("opencl"); }
#+end_src

* when argument of lambda_app is also lambda_app, it can be truncated
The =duplicate_ptr= function can sometimes take a pointer to a large
structure, and return a pointer to only the car of that structure.  To
see this view the output of the following.
#+begin_src sh
make ./test/fact-o-10.test && ./test/fact-o-10.test -v|grep expr|uniq|tail -20
#+end_src

see [[file:src/oncs.c::/*%20TODO:%20the%20cdr%20of%20in%20this%20place%20is%20not%20set%20correctly!%20*/][file:src/oncs.c::/* TODO: the cdr of in this place is not set correctly! */]]

Could be that we have places returned as free which have messages
heading their way.  So either don't return anything as free which has
incoming messages, or clear out the messages when it is made free.
Lets do the former.

* the undesirable fallback is always to lock the targets of λ-msgs
* somehow failures are related to the SIZE
| SIZE | failures            |
|------+---------------------|
|   16 | (fact-o-4 fact-o-6) |
|   32 | (fact-4)            |
|   64 | ()                  |

This could be due to overwriting of referenced ONCS, which could be
due to a need to increment refs when an ONC is duplicated onto the
queue by =duplicate_msgs=.  and.... yes, this fixes things, now all
tests are passing with SIZE=16.

* allow λ-messages in the tail of a lambda application
Otherwise, something simple like =(T 89 ...)= will never resolve.

* DONE when copying a pointer, copy its message queue as well
ok, so, when a λ-application is the argument to an a app_abs, there is
nothing to stop it from evaluating /while/ the corresponding
λ-messages are propagating from the body of the λ-application.

either
1. don't allow execution of structures which are the /arguments/ (not
   the targets) of λ-expressions, or more easily,
2. when copying a pointer, copy it's message queue as well

** implementation
copy_ptr is called from
- lambda_app of a LOCAL
- app_abs into the λ-msg and into the EXTEND-msg
- run.CURRIED application into place.cdr
- run.LAMBDA to propagate lambda messages (already in a message)
- run.EXTEND messages when applied

** BS
Like the cadr of the argument of the app may simply be lost.

to find the bad part of fact-o-2 break app_abs when
- place.car.car == #L0
- palce.cdr.car == #S0
- value_p(place.cdr)
- no incoming lambdas

break here
: (gdb) p world[4][15].car
: $12 = {hdr = 1, car = 4, cdr = 11}
: (gdb) p world[4][11].car
: $13 = {hdr = 4, car = 0, cdr = 0}
: (gdb) p world[4][11].cdr
: $14 = {hdr = 1, car = 4, cdr = 10}
: (gdb) p world[4][10].car
: $15 = {hdr = 3, car = 0, cdr = 0}
: (gdb) p place
: $16 = {x = 4, y = 15}
: (gdb) p place
:       {x = 8, y = 8}

: break app_abs if (place.x == 8 && place.y == 8 && world[4][15].car.hdr = 1 && world[4][15].car.car == 4 && world[4][15].car.cdr == 11 && world[4][11].car.hdr == 4 && world[4][11].car.car == 0 && world[4][10].car.hdr == 3 && world[4][10].car.car == 0)

#+begin_src C
break app_abs if (has_incoming_lambda(place) == 0 &&
                    world[place.x][place.y].car.hdr == 1 &&
                    world[world[place.x][place.y].car.car][world[place.x][place.y].car.cdr].car.hdr == 4 &&
                    world[world[place.x][place.y].car.car][world[place.x][place.y].car.cdr].car.car == 0 &&
                    world[world[place.x][place.y].car.car][world[place.x][place.y].car.cdr].car.cdr == 0 &&
                    world[world[place.x][place.y].car.car][world[place.x][place.y].car.cdr].cdr.hdr == 1 &&
                    world[world[world[place.x][place.y].car.car][world[place.x][place.y].car.cdr].cdr.car][world[world[place.x][place.y].car][world[place.x][place.y].cdr].cdr.cdr].car.hdr == 3 &&
                    world[world[world[place.x][place.y].car.car][world[place.x][place.y].car.cdr].cdr.car][world[world[place.x][place.y].car][world[place.x][place.y].cdr].cdr.cdr].car.car == 0)
#+end_src

* lambda applications are faster than lambda replacement messages
In y-comb-2 the =(< 1 #S3)= should not have been inserted because
the #S3 should have already been replaced by 0.  We have to propagate
lambda messages faster, as it is they are being "lapped" by the
process of lambda application.

This causes problems when part of an expression is consumed by app_abs
when it still has lambda-messages which haven't yet reached it.

** Here is an example
#+begin_example
  ((#L0 (#l1 (#S0 (#l2 ((#S1 #S1) #S2)))) (#l1 (#S0 (#l2 ((#S1 #S1) #S2)))))
   (#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))) 1

  ((#l1 (#S0 (#l2 ((#S1 #S1) #S2))))
   (#l1 (#S0 (#l2 ((#S1 #S1) #S2))))) 1

  ((#L1 (#S0 (#l2 ((#S1 #S1) #S2))))
   (#l1 (#S0 (#l2 ((#S1 #S1) #S2))))) 1

  ((#L1 (#S0 (#l2 ((#S1 #S1) #S2))))
   (#L1 (#S0 (#l2 ((#S1 #S1) #S2))))) 1

  ((#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
   (#L1 (#S0 (#l2 ((#S1 #S1) #S2))))) 1

  ((#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
   (#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) 1

  (((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2)))) 1

  (((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2)))) 1

  (((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#L2 ((#S1 #S1) #S2)))) 1

  (((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2)))) #S1) #S2)))) 1

  (((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                                      (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)))) 1

  (((#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))) 1
  (((#L3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))) 1

  (((#L3 ((< 1 #S3) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                               (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))))) 1

  (#L3 ((< 1 #S3) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                             (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))) 1

  ((< 1 #S3) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                        (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))

  ((<1 #S3) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                       (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))

  ((#L1 (#L0 #S0)) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                              (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))

  ((#L1 (#L0 #S0)) 89 ((#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                              (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))

  ((#L1 (#L0 #S0)) 89 ((#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                              (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (-1 #S3)))

  ((#L1 (#L0 #S0)) 89 ((#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                              (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) 0))

  ((#L1 (#L0 #S0)) 89 ((((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                         (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)))

  ((#L1 (#L0 #S0)) 89 ((((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                         (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) 0)))

  ((#L1 (#L0 #S0)) 89 ((((#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                         (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) 0)))

  ((#L1 (#L0 #S0)) 89 ((((#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                               (#l2 ((#S1 #S1) #S2))))
                         (#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                               (#l2 ((#S1 #S1) #S2))))) 0)))

  ((#L0 #S0))

  ((#L0 #S0) ((((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                (#l2 ((#S1 #S1) #S2)))) 0))

  ((#L0 #S0) ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                (#l2 ((#S1 #S1) #S2)))) 0))

  ((#L0 #S0) ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                (#L2 ((#S1 #S1) #S2)))) 0))

  ((#L0 #S0) ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2)))) #S1) #S2)))) 0))

  ((#L0 #S0) ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                       (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)))) 0))

  ((#L0 #S0) (((#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) 0))
  ((#L0 #S0) (((#L3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) 0))

  ((#L0 #S0) (((#L3 ((< 1 #S3) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                          (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3))))) 0))

  (#S0)

  ((((<1 #S3) 89 ((((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                    (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)))))

  ((((<1 #S3) 89 ((((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                    (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) (-1 #S3))))))

  ((((<1 #S3) 89 ((((#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                    (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) (-1 #S3))))))

  ((((<1 #S3) 89 ((((#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                    (#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) (-1 #S3))))))

  (((<1 #S3) 89 ((((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                   (#l2 ((#S1 #S1) #S2)))) (-1 #S3))))

  (((<1 #S3) 89 ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                   (#l2 ((#S1 #S1) #S2)))) (-1 #S3))))

  (((<1 #S3) 89 ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                   (#L2 ((#S1 #S1) #S2)))) (-1 #S3))))

  (((<1 #S3) 89 ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                   (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                          #S1) #S2)))) (-1 #S3))))

  (((<1 #S3) 89 ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                   (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                          (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)))) (-1 #S3))))

  (((<1 #S3) 89 (((#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (-1 #S3))))

  (((<1 #S3) 89 (((#L3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (-1 #S3))))

  (((<1 #S3) 89 (((#L3 ((< 1 #S3) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                             (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3))))) (-1 #S3))))

  ((<1 #S3) 89 ((#L3 ((< 1 #S3) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                           (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))) (-1 #S3)))

  ;; PROBLEM: The (< 1 #S3) should not have been inserted because the
  ;;          #S3 should have already been replaced by 0.  We have to
  ;;          propagate lambda messages faster, as it is they are being
  ;;          "lapped" by the process of lambda application.
  ((<1 #S3) 89 (((< 1 #S3) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                      (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))))

  ((<1 #S3) 89 (((<1 #S3) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                     (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))))

  ((<1 #S3) 89 (((<1 (-1 #S3)) 89 ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                          (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))))

  ;;          This should be a 0, but it
  ;;                never will be
  ;;                      |
  ;;                      v
  ((<1 #S3) 89 (((<1 (-1 #S3)) 89 ((#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                          (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (- 1 #S3)))))

  ((<1 #S3) 89 (((<1 (-1 #S3)) 89 ((#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                          (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (-1 #S3)))))

  ((<1 #S3) 89 (((<1 (-1 #S3)) 89 ((#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                          (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (-1 (-1 #S3))))))

  ((<1 #S3) 89 ((<1 (-1 #S3)) 89 ((((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                    (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2))))

  ((<1 #S3) 89 ((<1 (-1 #S3)) 89 ((((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                    (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) (-1 (-1 #S3))))))

  ((<1 #S3) 89 ((<1 (-1 #S3)) 89 ((((#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                    (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) (-1 (-1 #S3))))))

  ((<1 #S3) 89 ((<1 (-1 #S3)) 89 ((((#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                    (#L1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) (-1 (-1 #S3))))))

  ((<1 #S3) 89 ((<1 (-1 #S3)) 89 ((((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                                    (#l2 ((#S1 #S1) #S2)))) (-1 (-1 #S3)))))

  ((<1 #S3) 89 ((<1 (-1 #S3)) 89 ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                                    (#l2 ((#S1 #S1) #S2)))) (-1 (-1 #S3)))))

  ((<1 #S3) 89 ((<1 (-1 #S3)) 89 ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                                    (#L2 ((#S1 #S1) #S2)))) (-1 (-1 #S3)))))

  ((<1 #S3) 89 ((<1 (-1 #S3)) 89 ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                                    (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2)))) #S1) #S2)))) (-1 (-1 #S3)))))

  ((<1 #S3) 89 ((<1 (-1 #S3)) 89 ((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
                                    (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
                                           (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)))) (-1 (-1 #S3)))))

  ;; [...]

  ((<1 #S3) 89
  ((<1 (-1 #S3)) 89
  ((<1 (-1 (-1 #S3))) 89
  ((<1 (-1 (-1 (-1 #S3)))) 89
  ((<1 (-1 (-1 (-1 (-1 #S3))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 #S3)))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))))))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))))))))))))))))))) 89
  ((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3))))))))))))))))))))))))) 89
  (((<1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 (-1 #S3)))))))))))))))))))))))))) 89
    ((#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
            (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))) #S2)) (-1 #S3)))))))))))))))))))))))))))))

#+end_example

** GDB walk-through
1. starts with this
   : ((#L0 #S0)
   :  (((#L3
   :     ((< 1 #S3)
   :      89
   :      ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                    (#l2 ((#S1 #S1) #S2))))
   :              (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                    (#l2 ((#S1 #S1) #S2))))) #S2))
   :       (- 1 #S3)))))
   :   0))

2. the 0 is sent here
   : ((#L0 #S0)
   :  (((#L3
   :     |
   :     v
   :     ((< 1 #S3)
   :      89
   :      ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                    (#l2 ((#S1 #S1) #S2))))
   :              (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                    (#l2 ((#S1 #S1) #S2))))) #S2))
   :       (- 1 #S3)))))
   :   0))

3. after much running
   : ((#L0 #S0)
   :  (((#L1 (#L0 #S1)) 89
   :    (((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :        (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                     (#l2 ((#S1 #S1) #S2))))
   :               (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                     (#l2 ((#S1 #S1) #S2)))))
   :              #S2))))
   :      -1)))))

4. boolean replacement
   : ((#L0 #S0)
   :  (((#L1 (#L0 #S1))
   :    89 (((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :           (#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                        (#l2 ((#S1 #S1) #S2))))
   :                  (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                        (#l2 ((#S1 #S1) #S2))))) #S2))))
   :         -1)))))

5. the inner part reduces
   : ((#L0 #S0)
   :  (((#L1 (#L0 #S1))
   :    89
   :    (((((#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))) -1)))))

6. need to inhibit activity in the inner recursive calls
   : ((#L0 #S0) (((#L1 (#L0 #S1))
   :              89
   :              (((((#L3 ((< 1 #S3)
   :                        89
   :                        ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2))))
   :                                (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3))))) (#l2 ((#S1 #S1) #S2)))))
   :                               #S2))
   :                         (- 1 #S3))))))
   :                -1)))))

7. still grinding away
   : ((#L0 #S0)
   :  (((#L0 89)
   :    (((<1 #S3) 89
   :      ((#l2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                    (#l2 ((#S1 #S1) #S2))))
   :              (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                    (#l2 ((#S1 #S1) #S2))))) #S2))
   :       (- 1 #S3)))))))

** more eager queue reduction
1. first stop
   : ((#L0 #S0)
   :  (((< 1 0)
   :    89
   :    ((#L2 (((#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                  (#l2 ((#S1 #S1) #S2))))
   :            (#l1 ((#l4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :                  (#l2 ((#S1 #S1) #S2)))))
   :           #S2))
   :     (- 1 0)))))

2. then...
   : ((#L0 #S0)
   :  (((#L1 (#L0 #S1))
   :    89
   :    (((((#L4 (#l3 ((< 1 #S3) 89 (#S4 (- 1 #S3)))))
   :        (#l2 ((#S1 #S1) #S2)))) (-1))))))
   : 

* DONE need to lock lambdas as they are inserted into bodies of lambda expressions
* DONE need to lock curried operations and primitive operations
They are after all both just optimized versions of lambdas.

Storage of the lock
| lambda  | ptr.cdr |
| primopt | ptr.cdr |
| curried | ??????? |

Ugh, this is sort of ugly, but I may just stick this into the
header...

* order of operations to primitive operations matters
: (< #S1 1)
is different from
: (> 1 #S1)

Because the second form will curry sometimes resulting in different
convergence behavior.

a pernicious expansion of this second case is shown
: (#L3 ((<1 #S3) 89
:       ((#l2 (((#L3 ((<1 #S3) 89
:                     ((#l2 (((#L3 ((<1 #S3) 89
:                                   ...)))
:                            #S2))
:                      (-1 #S3)))))
:              #S2))
:        (-1 #S3))))
: 2
in which the top-level application of #L3 to 2 will never be performed
because the inner portion of the Y-combinator continue to expand ad
infinitum.

This means that we're not quite cbv, in the case of primitive
operations and curried primitive functions.

* replace =num_lambda_messages_for= with something faster (state?)
Any solution will require that the result for a particular ONC will
require interrogation of the value for all sub-oncs in the entire
structure.  If this will be maintained rather than calculated on the
fly (which is slow), then we'll need a way for ONCs to link /back/ up
to their parents...  This would be a fairly major change.

Track this in bits of state
- lambda-msg counter could count the number of lambda messages
  directed towards an ONC.  This could easily be maintained per ONC as
  messages are enqueued and dequeued.
- value-p bit could track if an ONC is value and update itself in
  response to lambda messages

Called from:
| func                    | for                                   |
|-------------------------+---------------------------------------|
| num_lambda_messages_for | recursion                             |
| app_abs                 | for the bodies of lambda applications |
| run                     | elimination of duplicate nesting      |

** DONE keep a counter of incoming lambda messages for each onc
After this change the time for running file:test/fact-o-2.c goes from
48 seconds to 5 seconds.

** assuming we add a backwards link
Tracking value-p of each ONC becomes the ∧ of the value-p of its car
and cdr, which are either immediately calculated by their type, or if
LOCAL are the result of the pointed-to ONC.  With backwards-facing
links then changes in value-p can be propagated back up the chain.

* why so slow
: $ time ./test/y-comb-2.test
: ./test/y-comb-2.test  51.51s user 0.00s system 99% cpu 51.583 total

** the culprit is obvious
gprof output for test/fact-o-2.test
: Each sample counts as 0.01 seconds.
:   %   cumulative   self              self     total
:  time   seconds   seconds    calls   s/call   s/call  name
:  90.55     44.75    44.75   640473     0.00     0.00  num_lambda_messages_for
:   4.96     47.20     2.45 34767872     0.00     0.00  coord_hash
:   2.53     48.45     1.25    33951     0.00     0.00  enqueue
:   0.51     48.70     0.25    33953     0.00     0.00  queue_hash
:   0.50     48.94     0.25    33953     0.00     0.00  run_all
:   0.45     49.16     0.22  5718842     0.00     0.00  run
:   0.18     49.25     0.09  5684891     0.00     0.00  run_at
:   0.16     49.33     0.08    67908     0.00     0.00  ptr_to_string
:   0.08     49.37     0.04   680828     0.00     0.00  value_p
:   0.06     49.40     0.03    33953     0.00     0.00  world_hash
:   0.02     49.41     0.01  5752890     0.00     0.00  debug
:   0.02     49.42     0.01   262687     0.00     0.00  app_abs
:   0.01     49.43     0.01        1     0.01    49.43  fix

** fact 2
: $ time test/fact-o-1.test
: test/fact-o-1.test  48.52s user 0.00s system 99% cpu 48.591 total

** fact 3
: 19:36 bagel:oncs time ./test/fact.test -v|tail -40
: Q[0]
: :
: expr(16,16):(*3 (*2))
: hash:12d68470
:
:      0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31
:  0                  i9^                     L2^             i1^         i1_
:  1                                      ^1_
:  2                                              ^1_ i9_ @1^
:  3                          i1^     L1^                     @10^                 ^1_
:  4                              i2^         @1^ @1^         @1^                 i1^
:  5
:  6                                      i1^ ^1_                 ^1_
:  7                                                          L1^     ^1^
:  8                                      ^1_                 ^1^ ^10^ ^1_
:  9                                                              L1^ L1^
: 10                                                                  ^1_
: 11
: 12
: 13
: 14
: 15                  ^10_
: 16              ^10_ ^10_         L1^ ^2_                             ^1_
: 17              ^1_
: 18                              L1^
: 19                              ^1_
: 20                                                  ^1_
: 21                                                  ^10_
: 22              i10_             ^10_                 ^1_
: 23                                      ^2_
: 24                                              s1_
: 25      s10_                         i1_ i1_     i2_     i1_
: 26              i10_
: 27      L10^     i1_                     ^1_ @1^
: 28      s1_ s10_         s2_                 s1_                                     s1_
: 29                      ^10_             @1^                 s1^                 ^1_ s10_
: 30                                          @1^ ^1_ i1_         s10^ ^1_     i2^     s1_
: 31                                          ^1_                 s1^                 i9^
: Q[0]
: :
: expr(16,16):(*3 (*2))
: hash:12d68470
: ./test/fact.test -v  53.27s user 1.31s system 99% cpu 54.681 total
: tail -40  2.04s user 1.00s system 5% cpu 54.681 total

* probably prim-opts need similar pre-exec checks to lambdas
Distill into a =safe_arg= or =safe_to_apply= function.

Maybe this is needed for EXTEND as well?

It looks like curried operations applied to =LOCAL='s pointing to
=LAMBDA='s end up erasing the =LAMBDA='s.

This could be a symptom
: ((*2 ((#L0 (= #S0 0 1 (* #S0 (-1 #S0)))) 1)))
: ((*2 )))

To see this up close run gdb overtop of primopt with
: break app_abs if place.x == 8 && place.y == 7

* DONE might consider de-nesting
So that =((1))= -> =1=.

This reduces the number of expressions, but may make writing and
evaluating expressions easier.

If this isn't done during evaluation then it should maybe be done
during translation of written expressions into ONC expressions.

* fact-0 bug
gdb
: break app_abs if (place.x == 8 && place.y == 4)
: break run     if (place.x == 8 && place.y == 4 && world[8][2].car.hdr == 2)

Somehow when =(-0 1)= is replace with =TRUE=, it's =cdr= is lost.

As if the boolean is =UNPACK='ed out from under the reference, which
then pushes the reference back to point part way into the =BOOLEAN=.

: =0 1 1 2
: TRUE 1 2

: +1 1 3 4
: 2 3 4

* consider inbound messages for ONCS which are moved in app_abs
=app_abs= will now /move/ linked ONCS into the place of a lambda
abstraction when it is applied.  This causes problems when those ONC
structures have inbound message.

** Ideas -- may need to revisit this on different architectures
*** DONE delay λ-application or app_abs when argument has λ-messages
The only time this happens over a distance is λ-application, so maybe
we can just deal with this at =lambda_app= and =app_abs=.

- Skip over =lambda_app= and =app_abs= when the argument has
  outstanding λ-messages.  Actually, if we just do this for =app_abs=
  then such arguments won't be enqueued and we don't need to worry
  about those on the queue.

*** apply message *before* the move
Actually, it would be better to /apply/ all message to the ONC before
it is duplicated away.  This avoids the two problems of;
- messages restarting propagation from the new location of the copied
  ONC could escape through to places it was never meant to visit
- large message duplication

Just this of this as pulling the ONC through it's message queue on its
way out of the square.  The problem then becomes, how to stall the
execution of the copying action while all of these other actions
complete.  It seems that any deviation from purely local interactions
(e.g., copying instantly and remotely in this case) tends to cause
problems down the line... Perhaps it is time to re-implement *all*
copy and movement through local messages.

*** copy messages
somehow copy (or duplicate) all messages in the queue to the new
location, like send a message down the queue which enqueues all
non-reference messages directed at the copied ONC to the target ONC.
This would work well with the future distributed queue, but could
likely greatly increase the total number of message applications, but
that doesn't really matter as they'll all take place in parallel.

*** stop moving any ONCS with references
Stop moving any ONCS with positive reference counts, and rather just
link to them, maybe with an UNPACK action.

** Possible worries
*** could an ONC be duplicated past a lambda replacement message
Picture an ONC which contains a symbol which is due to be replaced by
an incoming lambda message.  If this ONC is then duplicated *before*
the message is applied to someplace where the message will not reach,
then how will the message be applied?

* replace =requeue= as it violates consistency requirements
Violates the need for messages sent to a particular ONC to be received
in the order they are sent.

For now this has been fixed in the =fix= function (it now runs the
related ONC when such a situation is encountered), but a full solution
it still required.

* DONE ensure that referenced variables are never deleted
Somewhere there are poorly interleaved reference messages.

** Walking through file:test/examp-2.c execution with =gdb=.
| run (4,4)    |                           |                              |         |
| app_abs      |                           |                              |         |
|              | copy a to msg.cdr         | copy_ptr (3,2)               | (3,2)+1 |
|              | replace 2 with 4          | replace_ptr (3,3) with nil   | (3,3)-1 |
|              | replace 1 with 9          | replace_ptr (4,3) with (4,2) | (4,2)+1 |
|              |                           |                              | (4,3)-1 |
| λ app(4,2)   |                           |                              |         |
|              | copy down local pointer   | copy_ptr (3,2)               | (3,2)+1 |
|              | delete l_msg.mcdr         | delete_ptr (3,2)             | (3,2)-1 |
| run (3,2)+1  |                           |                              |         |
| run (3,3)-1  |                           | decrement msg to (3,2)       | (3,2)-1 |
| run (4,2)+1  |                           | increment msg to (4,1)       | (4,1)+1 |
| run (4,3)-1  |                           | decrement msg to (4,2)       | (4,2)-1 |
| run (3,2)+1  |                           |                              |         |
| λ msg (4,2)  |                           |                              |         |
|--------------+---------------------------+------------------------------+---------|
| λ app(4,1)   |                           |                              |         |
|              | copy down local pointer   | copy_ptr (3,2)               | (3.2)+1 |
|              | delete l_msg.mcdr         | delete_ptr (3,2)             | (3,2)-1 |
|              |                           |                              |         |
|              | copy target to cdr? (432) | copy_ptr (3,2)               | (3,2)+1 |
| λ app to nil |                           |                              |         |
|              |                           | delete_ptr (3,2)             | (3,2)-1 |
|              | cleanup target            | delete_ptr (3,2)             | (3,2)-1 |
|--------------+---------------------------+------------------------------+---------|
| run (3,2)-1  |                           |                              |         |
| run (3,2)-1  |                           |                              |         |
| run (4,1)+1  |                           | increment msg to (4,0)       | (4,0)+1 |
|              |                           |                              |         |

In the offset region above, the passing of a λ-message down an ONC
with *one* linked child, decrements the total number of references to
the target of the lambda message, while it should keep the original
value.

** Too many reference decrements in file:test/examp-1.c
Only when evaluated with =fix=, not when run with =run_down=.

Spot (7,6) has it's refs decremented down to 0 while it is referenced
by (7,7).  Thus, when (7,7) is duplicated into (8,2) or so, an open
space is requested and (7,6) *happens* to be returned, thus
overwriting it's value just before it's value is requested.

*** looking at senders of these messages w/printf debug
| message | from  | in      | why                   |
|---------+-------+---------+-----------------------|
| (7,7)-1 | (8,8) | app_abs | replace 1,2 with 9,10 |
| (7,6)-1 | (7,7) |         | propagate deletion    |
| (7,6)   | (7,6) |         | re-queue              |

*** analysis
in line 411 placed
#+begin_src C
    if(place.x == 7 && (place.y == 5 || place.y == 6))
      printf("(%d,%d)->%d\n", place.x, place.y, AT(place).mcar.car);
#+end_src

#+name: print-some-refs
#+begin_src sh
./test/examp-1.test |grep 5|cut -c8-
#+end_src

#+begin_src emacs-lisp :var messages=print-some-refs
  (format "%s"
           (let ((sum 1))
             (mapcar (lambda (new) (setq sum (+ sum new)))
                     messages)))
#+end_src

ref counts for (7,6)
: (2 3 4 3 2 3 2 1 2 3 4 3 2 3 2 1 0 1 2 1 0)

ref counts for (7,5)
: (2 3 4 3 2 1 0 1 2 1 2 3 2 1 2 1 0 -1 -2 -3)

* DONE cleanup leftover lambdas in symbols
[[file:test/cbv.c::/*%20TODO:%20Need%20to%20cleanup%202-each%20extra%20lambdas%20and%20symbols%20*/][file:test/cbv.c::/* TODO: Need to cleanup 2-each extra lambdas and symbols */]]

* ensure that free variables don't clash
variable renaming on application may not be implemented/working

* DONE lambdas are /evaporating/ through application to nil
Given that we're using =nil= for the ends of lists, we need to keep
lambdas from applying themselves to =nil= so they don't evaporate.

* y-comb.c evaluation order of operations
Will need some control over order of application.

See many papers here.
http://homepages.inf.ed.ac.uk/wadler/topics/call-by-need.html

| call by value | only values substituted into a lambda |
| normal order  | always work with the outermost redex  |
| call by name  | dont dive into a lambda               |

- Haskell is /call by name/ with laziness which makes it call by need.
- Java, C, ML etc... are all /call by value/

For now lets look at call by value.

** DONE use the cdr of lambda pointers to track locking information
currently a lambda expression holds something like
:   +-----------------------+
:   | λ | int id | empty    |
:   +-----------------------+
perhaps the could be replaced with
:   +-----------------------+
:   | λ | int id | locked   |
:   +-----------------------+

This way λ-messages propagating through ONC structures could carry
updating locking information down the structure.

** application abstractions
: app_abs(4,0) ((#L1 (#S0 (#L2 ((#S1 #S1) #S2)))) (#L1 (#S0 (#L2 ((#S1 #S1) #S2)))))
: app_abs(4,2) ((#L0 ((#S0 (#L2 ((#S1 #S1) #S2))))) (#L3 (#L4 ((= 0 #S4) 1 (* #S4 (#S3 (- 1 #S4)))))))
: app_abs(4,7) ((#L3 (#L4 ((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) (#L2 ((#S1 #S1) #S2)))

** raw expressions at place
#+begin_src sh
  ./test/y-comb.test -v|grep expr|sed 's/ )/)/g'|uniq|cut -c11-
#+end_src

: ((((#L0 (#L1 (#S0 #L2 ((#S1 #S1) #S2))) (#L1 (#S0 #L2 ((#S1 #S1) #S2)))) (#L3 (#L4 ((= 0 #S4) 1 (* #S4 (#S3 (- 1 #S4))))))) 2))
: ((((((#S0 #L2 ((#S1 #S1) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((#S1 #S1) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((#S0 #L2 ((#S1 #S1) #S2))) #S1) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((#S0 #L2 ((#S1 #S1) #S2))) ((#S0 #S0 (( #S1) #S2)))) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((((((#S0 #S0 (( #S1) #S2))))) #L2 ((#S1 #S1) #S2))) ((#S0 #S0 (( #S1) #S2)))) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((((((#S0 #S0 (( #S1) #S2))))) #L2 ((#S1 #S1) #S2))) (((#S0 #S0 (( #S1) #S2))))) #S2))))) 2))
: ((((((((((=0 #S4) 1 (* #S4 (#S3 (-1 #S4)))))) #L2 ((((((((#S0 ((((#S0 #S0 (( #S1) #S2))))) (( #S1) #S2))))) #L2 ((#S1 #S1) #S2))) (((#S0 ((((#S0 #S0 (( #S1) #S2))))) (( #S1) #S2))))) #S2))))) 2))

* play with y-comb in scheme
#+begin_src scheme
  ;; most naive, just duplicate function and pass it to itself
  (((lambda (f) (lambda (n) (if (zero? n) 1 (* n ((f f) (1- n))))))
    (lambda (f) (lambda (n) (if (zero? n) 1 (* n ((f f) (1- n)))))))
   4)

  ;; using a Y-combinator to handle function duplication
  (((lambda (m)
      ((lambda (f) (m (lambda (a) ((f f) a))))
       (lambda (f) (m (lambda (a) ((f f) a))))))
    (lambda (r) (lambda (n) (if (zero? n) 1 (* n (r (1- n))))))) 4)
#+end_src

* should implement a duplicate message type
* DONE unpack lambdas not just applications of curried functions
When replacing the pointer to the lambda application, don't point its
car at the body and its cdr at the following expressions, rather
follow the body down to its end, and point /that/ at the following
expressions.

Note, if the extension of the end of the body of the lambda expression
is done /before/ the lambda application message is sent, then the
message will /leak/ through to the following expressions.  So either,
1. the extension must be made /after/ the lambda application message
   has finished propagating or
2. the lambda application message must expire at the end of the body,
   which could be done through either counting, or some marker at the
   end of the body
3. even better, there could be an "extension" message, which could
   propagate down the structure after the lambda application message,
   ensuring that it is applied immediately after lambda replacement.

** DONE implement option (3) above with "extension" messages
* variables in the =run= function
** before
:                  ((λ1 s1 ...) a b ...)
:
:
:
:         +--------+--------+          +--------+--------+          +--------+--------+
:         |1       |2       |          |3       |4       |          |5       |6       |
:         |        |       -+--------> |   a    |       -+--------> |   b    |   ...  |
:         |   |    |        |          |        |        |          |        |        |
:         +---+----+--------+          +--------+--------+          +--------+--------+
:             |
:             |
:             v
:         +--------+--------+          +--------+--------+
:         |7       |8       |          |9       |10      |
:         |   λ1   |       -+--------> |   s1   |   ...  |
:         |        |        |          |        |        |
:         +--------+--------+          +--------+--------+

** goes to
:   +--+-+         ((λ1 s1 ...) a b ...)
:   |λ1|a|---+
:   +--+-+   |          +------------------------------------------------+
:            v          |                                                v
:         +--------+----+---+          +--------+--------+          +--------+--------+
:         |1       |2   |   |          |3       |4       |          |5       |6       |
:         |        |        |          |   a    |       -+--------> |   b    |   ...  |
:         |   |    |        |          |        |        |          |        |        |
:         +---+----+--------+          +--------+--------+          +--------+--------+
:             |
:             +----------------------------+
:                                          v
:         +--------+--------+          +--------+--------+
:         |7       |8       |          |9       |10      |
:         |   λ1   |       -+--------> |   s1   |   ...  |
:         |        |        |          |        |        |
:         +--------+--------+          +--------+--------+

Steps
1. make new msg
2. copy λ1 to msg.car
3. copy a to msg.cdr
4. replace (1,2) with (9,10)
5. msg goes to 1
6. replace end of 10 with 4

| functions | refs                                                       |
|-----------+------------------------------------------------------------|
| copy      | duplicates a pointer, if(pointer.hdr==LOCAL) target.refs++ |
| delete    | deletes a pointer, if(pointer.hdr==LOCAL) target.refs--    |

* dealing with "global" variables and environments
need to address this eventually, points to keep in mind
- build-ins which should be provided by the medium itself
- software transactional memory for widely referenced values
- the environment pointers from previous iterations

* DONE need to figure out how to un-shell results
When a function is applied to arguments, it must then /emerge/ from
the list enclosing the function and arguments.
: (+ 1 1) => 2
not
: (+ 1 1) => (2)

Some sort of new =PROMOTE= or =UNPACK= header argument.

* DONE better reading/writing between strings and ONCS
specifically currently it is necessary to include far too many
parenthesis specifying the linking order for lists, e.g., what should
be written as =(1 2 3 4 5)= must be written as =(1 (2 (3 (4 (5)))))=.

* direct debug output to STDERR
* DONE leftover lambda and (0,0) messages
For some reason after running some applications there are leftover
lambdas and messages sent to (0,0).

* DONE reading strings into ONCS
For example.
: (#L#S1 (#S1 #S1)) (1 (2 3))

* at some point replace all structs with binary data
  :PROPERTIES:
  :CUSTOM_ID: no-structs
  :END:
apparently every element of a struct is as large as the largest
structure, better to just use binary blobs and do my own pointer
arithmetic (macros should suffice).

* DONE should probably make =msg= its own structure
It should hold two pointers rather than just a single pointer.

once things are working we can replace this with something more
efficient (see [[#no-structs]]).

* DONE how to include a library that needs to create state
i.e., a header file that creates its own local variables... should it
have an init function?

just declare in both the .h and .c files
- oncs.h
  #+begin_src C
  /* global state */
  extern onc world[SIZE][SIZE];
  extern msg queue[];
  extern int qbeg, qend;
  #+end_src

- oncs.c
  #+begin_src C
  onc world[SIZE][SIZE];
  msg queue[QLENGTH];
  int qbeg, qend = 0;
  #+end_src

* other message types
- refresh (or some such) to indicate to a higher level portion of your
  structure that you have changed
- ready to be applied (for when I become a lambda and want to let the
  next level up know) -- although this would require up-pointers

* is it worth holding pointers to higher level
similar to the =env= pointer in earlier instantiating

* reverse lambdas -- matching lambdas with their applications
while
: (\lambda ..tons of stuff..)(argument)
seems like it would require lots of message passing to apply, the same
isn't true for
: (...tons of stuff...\lambda)(argument)

the key is just to start the application from the next level up

* eventually replace the global queue with something that lives in ONC world
* COMMENT Publishing
This code is used to publish this page to the =cs.unm.edu= webserver.
#+begin_src emacs-lisp :results silent
  (setq oncs-dir (file-name-directory (or load-file-name buffer-file-name)))
  (setq oncs-server "moons.cs.unm.edu") ;; was kenworth.cs.unm.edu
  (unless (boundp 'org-publish-project-alist)
    (setq org-publish-project-alist nil))
  ;; the main html page
  (add-to-list 'org-publish-project-alist
               `("oncs-html"
                 :section-numbers nil
                 :table-of-contents nil
                 :base-directory ,oncs-dir
                 :include ("README")
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/"
                                                oncs-server)
                 :publishing-function org-publish-org-to-html
                 :style "<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/
    pre{display:table-cell;background:#232323; color:#e6e1dc;}
    #content{max-width:1000px;margin:auto;} body{ font-size:small; } table{ font-size:small; }
    .outline-text-2{margin-left:2em;}.outline-text-3{margin-left:3em;}
    .title  { text-align: center; }
    p.verse { margin-left: 3% }
    p { text-align: justify }
    table { border-collapse: collapse; }
    td, th { vertical-align: top; }
    dt { font-weight: bold; }
    div.figure { padding: 0.5em; }
    div.figure p { text-align: center; }
    .linenr { font-size:smaller }
    #postamble { color: gray; padding-top: 2em; font-size: 0.75em; }
    /*]]>*/-->
  </style>"))
  ;; the contents of the base directory
  (add-to-list 'org-publish-project-alist
               `("oncs-data"
                 :base-directory ,oncs-dir
                 :include ("COPYING")
                 :base-extension "h\\|c\\|txt\\|lisp"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/"
                                                oncs-server)
                 :publishing-function org-publish-attachment))
  (add-to-list 'org-publish-project-alist
               `("oncs-src"
                 :base-directory ,(expand-file-name "src" oncs-dir)
                 :base-extension "h\\|c\\|txt\\|lisp"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/src/"
                                                oncs-server)
                 :publishing-function org-publish-attachment))
  (add-to-list 'org-publish-project-alist
               `("oncs-test"
                 :base-directory ,(expand-file-name "test" oncs-dir)
                 :base-extension "h\\|c\\|txt\\|lisp"
                 :publishing-directory ,(format "/ssh:eschulte@%s:~/public_html/code/oncs/test/"
                                                oncs-server)
                 :publishing-function org-publish-attachment))
  ;; a single combined project to publish both html and supporting materials
  (add-to-list 'org-publish-project-alist
               '("oncs" :components ("oncs-html" "oncs-data" "oncs-src" "oncs-test")))
#+end_src
