# -*- mode:org -*-
#+Title: ONCs -- are not conses
#+Author: Eric Schulte
#+License: GPLV3
#+Options: toc:nil ^:nil
#+Style: <style>pre{display:table-cell;} #content{max-width:1000px;margin:auto;}</style>

ONCs is a lisp virtual machine implemented as cons cells embedded in a
spatially extended medium of combined processing and memory elements.

* What is an ONC?
:  +--------------------------------------------+
:  |       Header                Data Words     |
:  | +------------------+  +------------------+ |
:  | |                  |  |       car        | |
:  | +------------------+  +------------------+ |
:  |                       +------------------+ |
:  |    Rule Table         |       cdr        | |
:  | +------------------+  +------------------+ |
:  | |     ------>      |  +------------------+ |
:  | |     ------>      |  |       env        | |
:  | +------------------+  +------------------+ |
:  +--------------------------------------------+

an ONC (/currently/) is composed of:
- Data Words :: probably 64-bit
  | car | either data or a pointer     |
  | cdr | either data or a pointer     |
  | env | a pointer to the environment |

- Header :: with information like
  | executable        | is it active (function) or passive (data)    |
  | serial            | resolve car/cdr in serial or parallel        |
  | weight/references | how big am I and how many things point to me |

- Rule Table :: which can map words of data to actions
  | =   | equality of car and cdr    |
  | -   | subtract car and cdr       |
  | +   | add car and cdr            |
  | xor | bitwise xor of car and cdr |
  | or  | bitwise or of car and cdr  |
  | and | bitwise and of car and cdr |
  | ... | more?                      |

** more about the headers
Some more information on the use of the header flags, hopefully most
flags will just be bits (although some will be counters) and the
header should fit into a word or two of memory.

- executable :: This determines whether the ONC should start
     processing itself.  This will generally be set to 1 for a
     function and to 0 for data, however it could also be set to 0 for
     a lazy function (which *is* data) which when set to 1 would then
     run.  This could also be used to implement serial execution in
     those cases where it is desired.  A list of functions could be
     run in serial by setting this to 0 for all but the first function
     and then mapping a function overtop which sequentially sets these
     flags to 1.

- serial :: This indicates whether the references (car and cdr) should
     be resolved in serial or parallel.  On a function ONC this /may/
     also be used to indicate if the function it associative which
     would affect how the function can be applied to large
     collections (maybe another associative flag would be needed).

- weight/references :: When a function is called on data the two will
     need to become co-located.  In some cases it will make more sense
     to copy the function towards the data and in some cases it will
     make more sense to move the data towards the function.

     If each NOC has a weight or incoming reference count which
     measures something like the size of the local reference net in
     which the NOC is participating then this decision may be made
     more intelligently.

     Maybe different counters should be used for outgoing and incoming
     references.

** more on environments
These resolve variables to values (addresses).  I imagine these would
exists on many different levels in a hierarchy.  Each would be
composed of a table mapping variables to values, and a pointer to the
next-level environment if the variable is not defined locally.

Each environment is composed of ONCs and each ONC can be thought of as
a tiny environment which only resolves car and cdr.

An ENV would basically be a list of =(var . val)= cons cells:
: ((name1 . val1) (name2 . val2) (name3 . val3))

For large environments a b-tree would be much faster allowing log(n)
look up times.
:            ^
:            | env
:          +---+              all lower level envs could
:    car /-|   |-\ cdr        point back up to the top of
:       /  +---+  \           the tree for quick return, if
:      /           \          return is required... don't know
:    +--+         +--+
:    |  |         |  |
:    +--+         +--+
:   /    \       /    \
:  +-+   +-+    +-+   +-+
:  | |   | |    | |   | |
:  +-+   +-+    +-+   +-+

* Language (non-VM) issues
Somewhere between lisp and λ-Calculus
- lispy notation with macros
- only single-arity functions with automatic currying with macro
  support for defining higher-arity functions without multiple lambdas
  so that =(λ x y . (+ x y))= \rightarrow =(λ x (λ y (+ x y)))=
- lisp-1 no separate name spaces for functions and data
- likely lazy evaluation like in Haskell
- by default *every* ONC is evaluated as soon as it appears in the
  medium but some special serialization constructs will be provided
- extensive use of =let= for defining mutable variables in clearly
  delimited scopes (which will map to specific ENVs and real physical
  regions of the execution medium)
- STM for variables over larger non-local scopes?
- possibly some data structures with high degree branching for
  efficient parallelism (like clojure)
- possibly function annotation (e.g., associative) like Fortress

* What would execution look like?
I don't know, hopefully naturally spreading out through the medium and
then collapsing as computation completes and code is replaced with its
results...

Should try to diagram out the execution of factorial.

: (def fac (λ x ((= x 0) x (* x (fac (- 1 x))))))
The above assumes both Booleans are represented as in λ-calc (i.e., T
is =(λ x y . x)= and F is =(λ x y . y)=).

Could expand to something like the following in the medium.

:  +-------+  +-------+  +-------+
:  |def|  -+->|fac|  -+->|   |nil|
:  +-------+  +-------+  +-+-----+
:                          |
:                          v
:                        +-------+  +-------+  +-------+
:                        | λ |  -+->| x |  -+->|   |nil|
:                        +-------+  +-------+  +-+-----+
:                                                |
:                                                v
:                                              +-------+  +-------+  +-------+  +-------+
:                                              |   |  -+->| x |  -+->|fac|  -+->|   |nil|
:                                              +-+-----+  +-------+  +-------+  +-+-----+
:                                                |                                |
:                                                |                                v
:                                                |                              +-------+  +-------+  +-------+
:                                                |                              | - |  -+->| 1 |  -+->| x |nil|
:                                                v                              +-------+  +-------+  +-------+
:                                              +-------+  +-------+  +-------+
:                                              | = |  -+->| x |  -+->| 0 |nil|
:                                              +-------+  +-------+  +-------+

* What would an ONC cell (empty or otherwise) need to do?
- pass messages
- find nearby empty cells (for placing new ONCS)
- maybe point to the environment

actions
- /quickly/ pass a message from one neighbor to another
- declare itself as empty or full
- perform local (in cell) computation
- respond to message with either local data or the result of local
  computation -- should it block until a result is computed?

fac
: 

y-combinator
: (def Ω)

Factorial of 6
1. With a combinator =Ω= and the recursive part of the factorial
   function =f=
   : f = (λ n ((= 0 n) 1 (* n (f (- n 1)))))
   : Ω = (λ f (λ x (f (x x))) (λ x (f (x x))))
2. combine these to create factorial
   : fac = (Ω f)
3. apply factorial to 6
   : (Ω f) 6
4. lookup Ω
   : ((λ f (λ x (f (x x))) (λ x (f (x x)))) (λ n ((= 0 n) 1 (* n (f (- n 1)))))) 6
5. apply the combinator
   : 

* How to move an onc with its references
When an onc moves to =new=, we need to start moving the car and cdr
references before the first onc lands (parallel not serial).  Their
targets become =new-car= and =new-cdr=.  How can they update their
landing location as the original onc gets established.
:   moves to location
:   "new"            
:        
:    +---+
:    |   | ---> moves to location
:    +-+-+      "new cdr"        
:      |                 
:      v                 
:  moves to location
:  "new car"        

sequence
1. onc moves
2. references follow
3. upon landing onc finds open car and cdr spaces
4. car and cdr land on top of onc, and follow these references to
   their new homes
5. and repeat...

* COMMENT Publishing
This code is used to publish this page to the =cs.unm.edu= webserver.
#+begin_src emacs-lisp :results silent
  (setq oncs-dir (file-name-directory (or load-file-name buffer-file-name)))
  (unless (boundp 'org-publish-project-alist)
    (setq org-publish-project-alist nil))
  ;; the main html page
  (add-to-list 'org-publish-project-alist
               `("oncs-html"
                  :base-extension "org"
                  :base-directory ,oncs-dir
                  :publishing-directory "/ssh:eschulte@moons.cs.unm.edu:~/public_html/code/oncs/"
                  :publishing-function org-publish-org-to-html
                  :style "<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/
    .title  { text-align: center; }
    .todo   { color: red; }
    .done   { color: green; }
    .tag    { background-color: #add8e6; font-weight:normal }
    .timestamp { color: #bebebe; }
    .timestamp-kwd { color: #5f9ea0; }
    p.verse { margin-left: 3% }
    p { text-align: justify }
    pre {
      background: #232323;
      color: #e6e1dc;
      border: 1pt solid #AEBDCC;
      padding: 5pt;
      overflow: auto;
      display: table-cell;
    }
    table { border-collapse: collapse; }
    td, th { vertical-align: top; }
    dt { font-weight: bold; }
    div.figure { padding: 0.5em; }
    div.figure p { text-align: center; }
    .linenr { font-size:smaller }
    #content { max-width: 1000px; margin: auto; }
    #postamble { color: gray; padding-top: 2em; font-size: 0.75em; }
    /*]]>*/-->
  </style>"))
  ;; the contents of the base directory
  (add-to-list 'org-publish-project-alist
               `("oncs-data"
                 :base-directory ,oncs-dir
                 :include ("COPYING")
                 :base-extension "lisp"
                 :publishing-directory "/ssh:eschulte@moons.cs.unm.edu:~/public_html/code/oncs/"
                 :publishing-function org-publish-attachment))
  ;; a single combined project to publish both html and supporting materials
  (add-to-list 'org-publish-project-alist
               '("oncs" :components
                 ("oncs-html"
                  "oncs-data"
                  "oncs-evolution")))
#+end_src
