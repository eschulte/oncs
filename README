# -*- mode:org -*-
#+Title: ONCs -- are not conses
#+Author: Eric Schulte
#+License: GPLV3
#+Options: ^:nil toc:nil num:nil
#+Style: <style>pre{display:table-cell;background:#232323;color:#e6e1dc;}</style>
#+Style: <style>#content{max-width:1000px;margin:auto;}</style>
#+Style: <style>.outline-text-2{margin-left: 2em;}.outline-text-3{margin-left: 3em;}</style>

ONCs is a lisp virtual machine implemented as cons cells embedded in a
spatially extended medium of combined processing and memory elements.

* Distributed Processing and Storage
: +--+--+--+--+--+--+--+--+
: |  |  |  |  |  |  |  |  |
: +--+--    ONCS    +--+--+   The machine is composed of a field of ONCs.
: |  |  |  |  |  |  |  |  |
: +--+--+--+--+--+--+--+--+
: |  |  |  |  |  |  || |  |
: +--+--+--+--+--+--++-+--+
: |  |  |<-+--+-messages- |   Computation occurs in parallel in the form of
: +--+--+--+--+--+--++-+--+   messages passing between ONCs.
: |  |  |  |  |  |  |v |  |
: +--+--+--+--+--+--+--+--+

** ONC
Each ONC serves both as a location for storage and local processing.
ONCs have the following internal structure.
#+begin_src C
  struct onc        // +----------------+
  {                 // |      ONC       |
    long long hdr;  // | header    byte |
    long long env;  // | env       word |
    long long msg;  // | message   word |
    long long car;  // | car       word |
    long long cdr;  // | cdr       word |
  };                // +----------------+
#+end_src
- header :: holds information controlling the execution of the ONC,
     including how it responds to messages
     | executable        | is it active (function) or passive (data)    |
     | serial            | resolve car/cdr in serial or parallel        |
     | weight/references | how big am I and how many things point to me |
     | pass through      | just pass incoming messages through          |
     | hold?             | not accepting messages                       |
- environment :: a pointer to the environment which should be used to
     resolve local variables
- message :: a local work space in which incoming messages and
     temporary addresses (e.g., used to direct transient messages)
- car and cdr :: either raw data or the pointers with which linked
     cons structures are built

** Message
Messages move information between ONCs.  Messages are streams of
/headers/ and /payloads/.
#+begin_src C
  /* Message Payloads */
  typedef unsigned long long word;
  /* Message Headers */
  typedef unsigned char header;
#+end_src
Payloads carry raw data and headers indicate how payloads are to be
processed along the following rules.
#+begin_src C
  switch( head ){
   case 7: /* 1 1 1 0 -- direct to value of payload in env */    break;
   case 3: /* 1 1 0 0 -- direct to local direction in payload */ break;
   case 5: /* 1 0 1 0 -- direct to value in car */               break;
   case 1: /* 1 0 0 0 -- direct to value in cdr */               break;
   case 6: /* 0 1 1 0 -- store payload in message */             break;
   case 2: /* 0 1 0 0 -- store payload in env */                 break;
   case 4: /* 0 0 1 0 -- store payload in car */                 break;
   case 0: /* 0 0 0 0 -- store payload in cdr */                 break;
   }
#+end_src

** States of ONCs -- header values and their meanings
As mentioned above headers will have the following flags.
| executable        | is it active (function) or passive (data)    |
| serial            | resolve car/cdr in serial or parallel        |
| weight/references | how big am I and how many things point to me |
| pass through      | just pass incoming messages through          |
| hold?             | not accepting messages                       |
We can order these as follows into an 8-bit byte.
: [ executable | serial | pass-through | hold | size...4.bits...]

* COMMENT Pontification
** What is an ONC?
:  +--------------------------------------------+
:  |       Header                Data Words     |
:  | +------------------+  +------------------+ |
:  | |                  |  |       car        | |
:  | +------------------+  +------------------+ |
:  |                       +------------------+ |
:  |    Rule Table         |       cdr        | |
:  | +------------------+  +------------------+ |
:  | |     ------>      |  +------------------+ |
:  | |     ------>      |  |       env        | |
:  | +------------------+  +------------------+ |
:  +--------------------------------------------+

an ONC (/currently/) is composed of:
- Data Words :: probably 64-bit
  | car | either data or a pointer     |
  | cdr | either data or a pointer     |
  | env | a pointer to the environment |

- Header :: with information like
  | executable        | is it active (function) or passive (data)    |
  | serial            | resolve car/cdr in serial or parallel        |
  | weight/references | how big am I and how many things point to me |
  | pass through      | just pass incoming messages through          |

- Rule Table :: which can map words of data to actions
  | =   | equality of car and cdr    |
  | -   | subtract car and cdr       |
  | +   | add car and cdr            |
  | xor | bitwise xor of car and cdr |
  | or  | bitwise or of car and cdr  |
  | and | bitwise and of car and cdr |
  | ... | more?                      |

*** more about the headers
Some more information on the use of the header flags, hopefully most
flags will just be bits (although some will be counters) and the
header should fit into a word or two of memory.

- executable :: This determines whether the ONC should start
     processing itself.  This will generally be set to 1 for a
     function and to 0 for data, however it could also be set to 0 for
     a lazy function (which *is* data) which when set to 1 would then
     run.  This could also be used to implement serial execution in
     those cases where it is desired.  A list of functions could be
     run in serial by setting this to 0 for all but the first function
     and then mapping a function overtop which sequentially sets these
     flags to 1.

- serial :: This indicates whether the references (car and cdr) should
     be resolved in serial or parallel.  On a function ONC this /may/
     also be used to indicate if the function it associative which
     would affect how the function can be applied to large
     collections (maybe another associative flag would be needed).

- weight/references :: When a function is called on data the two will
     need to become co-located.  In some cases it will make more sense
     to copy the function towards the data and in some cases it will
     make more sense to move the data towards the function.

     If each NOC has a weight or incoming reference count which
     measures something like the size of the local reference net in
     which the NOC is participating then this decision may be made
     more intelligently.

     Maybe different counters should be used for outgoing and incoming
     references.

*** more on environments
These resolve variables to values (addresses).  I imagine these would
exists on many different levels in a hierarchy.  Each would be
composed of a table mapping variables to values, and a pointer to the
next-level environment if the variable is not defined locally.

Each environment is composed of ONCs and each ONC can be thought of as
a tiny environment which only resolves car and cdr.

An ENV would basically be a list of =(var . val)= cons cells:
: ((name1 . val1) (name2 . val2) (name3 . val3))

For large environments a b-tree would be much faster allowing log(n)
look up times.
:            ^
:            | env
:          +---+              all lower level envs could
:    car /-|   |-\ cdr        point back up to the top of
:       /  +---+  \           the tree for quick return, if
:      /           \          return is required... don't know
:    +--+         +--+
:    |  |         |  |
:    +--+         +--+
:   /    \       /    \
:  +-+   +-+    +-+   +-+
:  | |   | |    | |   | |
:  +-+   +-+    +-+   +-+

** Language (non-VM) issues
Somewhere between lisp and λ-Calculus
- lispy notation with macros
- only single-arity functions with automatic currying with macro
  support for defining higher-arity functions without multiple lambdas
  so that =(λ x y . (+ x y))= \rightarrow =(λ x (λ y (+ x y)))=
- lisp-1 no separate name spaces for functions and data
- likely lazy evaluation like in Haskell
- by default *every* ONC is evaluated as soon as it appears in the
  medium but some special serialization constructs will be provided
- extensive use of =let= for defining mutable variables in clearly
  delimited scopes (which will map to specific ENVs and real physical
  regions of the execution medium)
- STM for variables over larger non-local scopes?
- possibly some data structures with high degree branching for
  efficient parallelism (like clojure)
- possibly function annotation (e.g., associative) like Fortress

** What would execution look like?
I don't know, hopefully naturally spreading out through the medium and
then collapsing as computation completes and code is replaced with its
results...

Should try to diagram out the execution of factorial.

: (def fac (λ x ((= x 0) x (* x (fac (- 1 x))))))
The above assumes both Booleans are represented as in λ-calc (i.e., T
is =(λ x y . x)= and F is =(λ x y . y)=).

Could expand to something like the following in the medium.

:  +-------+  +-------+  +-------+
:  |def|  -+->|fac|  -+->|   |nil|
:  +-------+  +-------+  +-+-----+
:                          |
:                          v
:                        +-------+  +-------+  +-------+
:                        | λ |  -+->| x |  -+->|   |nil|
:                        +-------+  +-------+  +-+-----+
:                                                |
:                                                v
:                                              +-------+  +-------+  +-------+  +-------+
:                                              |   |  -+->| x |  -+->|fac|  -+->|   |nil|
:                                              +-+-----+  +-------+  +-------+  +-+-----+
:                                                |                                |
:                                                |                                v
:                                                |                              +-------+  +-------+  +-------+
:                                                |                              | - |  -+->| 1 |  -+->| x |nil|
:                                                v                              +-------+  +-------+  +-------+
:                                              +-------+  +-------+  +-------+
:                                              | = |  -+->| x |  -+->| 0 |nil|
:                                              +-------+  +-------+  +-------+

** What would an ONC cell (empty or otherwise) need to do?
- pass messages
- find nearby empty cells (for placing new ONCS)
- maybe point to the environment

actions
- /quickly/ pass a message from one neighbor to another
- declare itself as empty or full
- perform local (in cell) computation
- respond to message with either local data or the result of local
  computation -- should it block until a result is computed?

Factorial of 6
1. With a combinator =Ω= and the recursive part of the factorial
   function =f=
   : f = (λ n ((= 0 n) 1 (* n (f (- n 1)))))
   : Ω = (λ f (λ x (f (x x))) (λ x (f (x x))))
2. combine these to create factorial
   : fac = (Ω f)
3. apply factorial to 6
   : (Ω f) 6
4. lookup =Ω= and =f=
   : ((λ f (λ x (f (x x))) (λ x (f (x x)))) (λ n ((= 0 n) 1 (* n (f (- n 1)))))) 6
5. apply =Ω= to =f=
   : ...
6. apply =f= to =6=
   : ...

** How to move an onc with its references
When an onc moves to =new=, we need to start moving the car and cdr
references before the first onc lands (parallel not serial).  Their
targets become =new-car= and =new-cdr=.  How can they update their
landing location as the original onc gets established.
:   moves to location
:   "new"
:
:    +---+
:    |   | ---> moves to location
:    +-+-+      "new cdr"
:      |
:      v
:  moves to location
:  "new car"

sequence
1. onc moves
2. references follow
3. upon landing onc finds open car and cdr spaces
4. car and cdr land on top of onc, and follow these references to
   their new homes
5. and repeat...

** Objects and their structure and functions
*** reference
Three types of references
- local reference, e.g., over two up one
- variable references, e.g., the variable named =foo=
- car and cdr which mean to follow the car or cdr pointer of the
  current onc

Each type of reference may include pointers relative to that
reference.  So for example =ref:cdr:car= would mean to find =ref=,
then go to the =cdr= of =ref=, and then the =car= of that =cdr=.

So either references will need to be variable size, or there will be
room for a limited number of further sub-references... lets say
variable sized, and the reference is just the head of a message which
can be as large as it wants and is read off the front of the message
in order.

So a message could be as follows which is just read from the top down
:           Message                                           Message at cdr
:   +--------------------+                                       of ref
:   | Reference  ref     |          Message at ref          +---------------+
:   |           ---------|       +------------------+       | Ref:   car    |        Message at car
:   |            cdr     |       | Reference   cdr  |       |               |         of cdr of ref
:   |           ---------|  ref  |          --------|  cdr  |               |  car   +------------+
:   |            car     | ----> |             car  | ----> |---------------| ---->  | Pay: data  |
:   |--------------------|       |------------------|       | Pay:   data   |        +------------+
:   | Payload    data    |       | Payload  data    |       +---------------+
:   +--------------------+       +------------------+
:         follow ref                 follow cdr                 follow car             insert data

These could also be interspersed... after all large data blocks will
necessarily have a cons structure (e.g., need to be split up amongst
multiple oncs).

*** message
Mixed references and data, references are followed and data is
inserted.  It may also be useful to have some sort of =split=
operator, so that a reference at the front of a message could be
followed up to a certain point, and then be split into two messages to
go different places from that location.  Although maybe leave that
alone for now, no need for premature optimization, lets just send
multiple messages and see if we get flooded.

Simple message, drop data =bar= at reference =foo=.
: +-----------+
: | foo | bar |
: +-----------+

Formally let a message just be a list of words of arbitrary length,
where words are as defined below, some indicator bit to say if they
are data or reference, followed by contents.

*** words and headers
- 4 bit headers
- 64-bit words

message headers -- 1 byte
| 1 1 1 0 | variable | 7 |
| 1 1 0 0 | local    | 3 |
| 1 0 1 0 | car      | 5 |
| 1 0 0 0 | cdr      | 1 |
| 0 1 1 0 | message  | 6 |
| 0 1 0 0 | env data | 2 |
| 0 0 1 0 | car data | 4 |
| 0 0 0 0 | cdr data | 0 |

*** onc
- onc header 64 bits
- env 64 bits
- car 64 bits
- cdr 64 bits

*** functions
- convert a linked onc structure to a message stream -- just
  recursively convert oncs
- lookup a variable and send a message to that location

* COMMENT Publishing
This code is used to publish this page to the =cs.unm.edu= webserver.
#+begin_src emacs-lisp :results silent
  (setq oncs-dir (file-name-directory (or load-file-name buffer-file-name)))
  (unless (boundp 'org-publish-project-alist)
    (setq org-publish-project-alist nil))
  ;; the main html page
  (add-to-list 'org-publish-project-alist
               `("oncs-html"
                  :base-directory ,oncs-dir
                  :include ("README")
                  :publishing-directory "/ssh:eschulte@moons.cs.unm.edu:~/public_html/code/oncs/"
                  :publishing-function org-publish-org-to-html
                  :style "<style type=\"text/css\">\n <!--/*--><![CDATA[/*><!--*/
    .title  { text-align: center; }
    .todo   { color: red; }
    .done   { color: green; }
    .tag    { background-color: #add8e6; font-weight:normal }
    .timestamp { color: #bebebe; }
    .timestamp-kwd { color: #5f9ea0; }
    p.verse { margin-left: 3% }
    p { text-align: justify }
    pre {
      background: #232323;
      color: #e6e1dc;
      border: 1pt solid #AEBDCC;
      padding: 5pt;
      overflow: auto;
      display: table-cell;
    }
    table { border-collapse: collapse; }
    td, th { vertical-align: top; }
    dt { font-weight: bold; }
    div.figure { padding: 0.5em; }
    div.figure p { text-align: center; }
    .linenr { font-size:smaller }
    #content { max-width: 1000px; margin: auto; }
    #postamble { color: gray; padding-top: 2em; font-size: 0.75em; }
    /*]]>*/-->
  </style>"))
  ;; the contents of the base directory
  (add-to-list 'org-publish-project-alist
               `("oncs-data"
                 :base-directory ,oncs-dir
                 :include ("COPYING")
                 :base-extension "c"
                 :publishing-directory "/ssh:eschulte@moons.cs.unm.edu:~/public_html/code/oncs/"
                 :publishing-function org-publish-attachment))
  ;; a single combined project to publish both html and supporting materials
  (add-to-list 'org-publish-project-alist
               '("oncs" :components
                 ("oncs-html"
                  "oncs-data"
                  "oncs-evolution")))

#+end_src
